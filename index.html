<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación Tráfico WebGL - Vanilla JS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (Global CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Contadores Flotantes (UI) */
        .sensor-counter {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #22d3ee; /* cyan-400 */
            border: 2px solid #06b6d4; /* cyan-500 */
            font-size: 1.5rem;
            font-weight: bold;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 50px;
        }
        .sensor-label {
            display: block;
            font-size: 0.6rem;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: -2px;
        }
        
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.95);
            border: 1px solid #374151;
            backdrop-filter: blur(4px);
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>

    <!-- UI: Contadores Flotantes -->
    <div id="counter-a1" class="sensor-counter">
        <span id="valA1">0</span>
        <span class="sensor-label" data-label-a1>A1</span>
    </div>
    <div id="counter-a7" class="sensor-counter">
        <span id="valA7">0</span>
        <span class="sensor-label" data-label-a7>A7</span>
    </div>
    <div id="counter-a3" class="sensor-counter">
        <span id="valA3">0</span>
        <span class="sensor-label" data-label-a3>A3</span>
    </div>
    <div id="counter-a5" class="sensor-counter">
        <span id="valA5">0</span>
        <span class="sensor-label" data-label-a5>A5</span>
    </div>

    <!-- UI: Controles -->
    <div class="absolute bottom-6 left-6 right-6 flex flex-col md:flex-row justify-between items-end gap-4 pointer-events-none z-20">
        
        <!-- Slider Densidad -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto w-full md:w-72">
            <label class="block text-sm font-bold mb-2 text-cyan-400 flex justify-between">
                <span>Densidad Tráfico</span>
                <span id="density-val">50%</span>
            </label>
            <input id="density-slider" type="range" min="1" max="100" value="50" 
                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
        </div>

        <!-- Botón Modo -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto flex items-center gap-4">
            <div>
                <p class="text-xs text-gray-400 mb-1 uppercase tracking-wider">Estado</p>
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></div>
                    <span id="status-text" class="font-bold text-sm">INTELIGENTE</span>
                </div>
            </div>
            <button id="mode-btn" 
                    class="px-4 py-2 rounded font-bold transition-all bg-cyan-600 hover:bg-cyan-500 text-white shadow text-sm border-b-2 border-cyan-800 active:border-b-0 active:translate-y-0.5">
                Cambiar Modo
            </button>
        </div>
    </div>

    <!-- Lógica Principal -->
    <script type="text/javascript">
        window.onload = function() {
            
            // --- CONFIGURACIÓN GEOMÉTRICA (BASADO EN IMAGEN) ---
            const ROAD_WIDTH_V = 40; // Ancho calle Vertical (N-S)
            const ROAD_WIDTH_H = 40; // Ancho avenida Horizontal (E-O)
            const MEDIAN_WIDTH = 4;
            const ROAD_LENGTH = 250; 
            const SIMULATION_SPEED = 0.3; 
            
            // --- CÁLCULO DE CARRILES Y LÍNEAS DE DETENCIÓN ---
            const LANE_WIDTH_V = (ROAD_WIDTH_V - MEDIAN_WIDTH) / 2;
            const LANE_WIDTH_H = (ROAD_WIDTH_H - MEDIAN_WIDTH) / 2;
            const LANE_CENTER_V = MEDIAN_WIDTH / 2 + LANE_WIDTH_V / 2; // Distancia del centro de la calle al centro del carril
            const LANE_CENTER_H = MEDIAN_WIDTH / 2 + LANE_WIDTH_H / 2;
            const LANE_OFFSET = LANE_WIDTH_V / 4; // Desplazamiento desde el centro de la vía direccional al centro de un carril
            
            const STOP_LINE_OFFSET = 4;
            const STOP_LINE_N = -ROAD_WIDTH_H / 2 - STOP_LINE_OFFSET; // Para A1 (desde Norte)
            const STOP_LINE_S = ROAD_WIDTH_H / 2 + STOP_LINE_OFFSET;  // Para A5 (desde Sur)
            const STOP_LINE_E = ROAD_WIDTH_V / 2 + STOP_LINE_OFFSET;  // Para A3 (desde Este)
            const STOP_LINE_W = -ROAD_WIDTH_V / 2 - STOP_LINE_OFFSET; // Para A7 (desde Oeste)

            // --- ZONA SENSOR ---
            const SENSOR_ZONE_LEN = 40; 

            // Enumeraciones
            const Direction = { NORTH: 'NORTH', SOUTH: 'SOUTH', EAST: 'EAST', WEST: 'WEST' };
            const LightState = { RED: 'RED', YELLOW: 'YELLOW', GREEN: 'GREEN' };
            
            // --- CONFIGURACIÓN DE VEHÍCULOS ---
            const VEHICLE_TYPES = {
                CAR: {
                    name: 'CAR',
                    baseLength: 6.0,
                    baseWidth: 2.8,
                    maxSpeed: [25, 20], // base, random
                    acceleration: [0.1, 0.1],
                    colorPool: [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316, 0x64748b]
                },
                TRUCK: {
                    name: 'TRUCK',
                    baseLength: 10.5,
                    baseWidth: 3.2,
                    maxSpeed: [20, 15],
                    acceleration: [0.05, 0.05],
                    colorPool: [0x4b5563, 0x78716c, 0x064e3b, 0x92400e]
                },
                MOTORCYCLE: {
                    name: 'MOTORCYCLE',
                    baseLength: 3.5,
                    baseWidth: 1.2,
                    maxSpeed: [35, 25],
                    acceleration: [0.2, 0.2],
                    colorPool: [0xdc2626, 0x1d4ed8, 0x000000, 0xeeeeee]
                }
            };
            
            // Variables Globales
            let scene, camera, renderer, clock;
            let cars = []; // Now represents all vehicles
            let density = 50;
            let isSmartMode = true;
            let controller;
            let nextSpawnTime = 0;

            // Elementos DOM
            const counters = {
                a1: { el: document.getElementById('counter-a1'), val: document.getElementById('valA1') },
                a3: { el: document.getElementById('counter-a3'), val: document.getElementById('valA3') },
                a5: { el: document.getElementById('counter-a5'), val: document.getElementById('valA5') },
                a7: { el: document.getElementById('counter-a7'), val: document.getElementById('valA7') }
            };
            const elDensityVal = document.getElementById('density-val');
            const elStatusText = document.getElementById('status-text');
            const elStatusDot = document.getElementById('status-dot');
            
            class TrafficController {
                constructor(scene) {
                    this.stateV = LightState.GREEN; // North-South
                    this.stateH = LightState.RED;   // East-West
                    this.timerV = 0; this.timerH = 0; this.cycleTimer = 0;
                    this.transitioning = false;

                    this.MIN_GREEN = 3.0; this.MAX_GREEN = 12.0;
                    this.YELLOW_TIME = 1.0; 
                    this.PRE_GREEN_YELLOW_TIME = 1.0;
                    this.FIXED_TIME = 5.0; 

                    this.buildInfrastructure(scene); 
                    this.updateVisuals();           
                }

                buildInfrastructure(scene) {
                    const createTrafficLight = (x, z, rotation) => {
                        const group = new THREE.Group();
                        const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
                        const housing = new THREE.Mesh(new THREE.BoxGeometry(3.5, 5, 3.5), housingMat);

                        const colorBulb = new THREE.Mesh(new THREE.SphereGeometry(1.1, 16, 16), new THREE.MeshBasicMaterial({ color: 0x111111 }));
                        colorBulb.position.set(0, 0, 1.8);

                        housing.add(colorBulb);
                        group.add(housing);
                        group.position.set(x, 3, z);
                        group.rotation.y = rotation;
                        scene.add(group);
                        return { colorBulb: colorBulb };
                    };
                    
                    const offsetX = ROAD_WIDTH_V / 2 + 3;
                    const offsetZ = ROAD_WIDTH_H / 2 + 3;
                    
                    this.lights = {
                        north: createTrafficLight(-offsetX, -offsetZ, Math.PI),
                        south: createTrafficLight(offsetX, offsetZ, 0),
                        east: createTrafficLight(offsetX, -offsetZ, Math.PI / 2),
                        west: createTrafficLight(-offsetX, offsetZ, -Math.PI / 2)
                    };
                }

                updateLightVisuals(lightObject, state) {
                    let color = 0x111111;
                    if (state === LightState.RED) color = 0xff0000;
                    else if (state === LightState.GREEN) color = 0x00ff00;
                    else if (state === LightState.YELLOW) color = 0xffaa00;
                    lightObject.colorBulb.material.color.setHex(color);
                }

                updateVisuals() {
                    this.updateLightVisuals(this.lights.north, this.stateV);
                    this.updateLightVisuals(this.lights.south, this.stateV);
                    this.updateLightVisuals(this.lights.east, this.stateH);
                    this.updateLightVisuals(this.lights.west, this.stateH);
                }

                switchLight(giveGreenTo) {
                    if (this.transitioning || (giveGreenTo === 'V' && this.stateV === LightState.GREEN) || (giveGreenTo === 'H' && this.stateH === LightState.GREEN)) return;
                    this.transitioning = true;

                    if (this.stateV === LightState.GREEN) { this.stateV = LightState.YELLOW; }
                    if (this.stateH === LightState.GREEN) { this.stateH = LightState.YELLOW; }
                    
                    setTimeout(() => {
                        if (giveGreenTo === 'V') { this.stateH = LightState.RED; this.stateV = LightState.YELLOW; } 
                        else { this.stateV = LightState.RED; this.stateH = LightState.YELLOW; }
                        
                        setTimeout(() => {
                            this.stateV = (giveGreenTo === 'V') ? LightState.GREEN : LightState.RED;
                            this.stateH = (giveGreenTo === 'H') ? LightState.GREEN : LightState.RED;
                            this.timerV = 0; this.timerH = 0;
                            this.transitioning = false;
                        }, this.PRE_GREEN_YELLOW_TIME * 1000 / SIMULATION_SPEED);

                    }, this.YELLOW_TIME * 1000 / SIMULATION_SPEED);
                }

                updateLogic(dt, counts) {
                    this.timerV += dt;
                    this.timerH += dt;

                    if (this.transitioning) { this.updateVisuals(); return; }

                    if (isSmartMode) {
                        const totalV = counts.a1 + counts.a5;
                        const totalH = counts.a3 + counts.a7;
                        if (this.stateV === LightState.GREEN && this.timerV > this.MIN_GREEN) {
                            if ((totalH > totalV) || (totalV === 0 && totalH > 0) || this.timerV > this.MAX_GREEN) this.switchLight('H');
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MIN_GREEN) {
                            if ((totalV > totalH) || (totalH === 0 && totalV > 0) || this.timerH > this.MAX_GREEN) this.switchLight('V');
                        }
                    } else {
                        if (this.stateV === LightState.GREEN && this.timerV > this.FIXED_TIME) this.switchLight('H');
                        else if (this.stateH === LightState.GREEN && this.timerH > this.FIXED_TIME) this.switchLight('V');
                    }
                    this.updateVisuals();
                }
            }

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff); 
                const container = document.getElementById('canvas-container');

                const aspect = window.innerWidth / window.innerHeight;
                const d = 80;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                camera.position.set(0, 100, 0); 
                camera.lookAt(0, 0, 0); 

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                scene.add(new THREE.AmbientLight(0xffffff, 0.9));

                createGround(); 
                createRoads(); 
                createSensorVisuals(); 
                createDashedBorders();
                createMedianBorders();
                createLaneMarkings();

                controller = new TrafficController(scene); 
                window.addEventListener('resize', onResize);
                document.getElementById('density-slider').addEventListener('input', (e) => { density = parseInt(e.target.value); elDensityVal.innerText = density + '%'; });
                document.getElementById('mode-btn').addEventListener('click', () => {
                    isSmartMode = !isSmartMode;
                    elStatusText.innerText = isSmartMode ? 'INTELIGENTE' : 'FIJO';
                    elStatusDot.classList.toggle('bg-green-500', isSmartMode);
                    elStatusDot.classList.toggle('bg-yellow-500', !isSmartMode);
                    controller.timerV = 0;
                    controller.timerH = 0;
                });
                
                const loader = new THREE.FontLoader();
                loader.load('https://raw.githack.com/mrdoob/three.js/master/examples/fonts/helvetiker_bold.typeface.json', font => {
                    createStreetLabels(font);
                });

                clock = new THREE.Clock();
                animate();
            }

            function createGround() {
                const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshBasicMaterial({ color: 0xeeeeee }));
                ground.rotation.x = -Math.PI / 2; ground.position.y = -0.1; 
                scene.add(ground);
            }

            function createRoads() {
                const roadMat = new THREE.MeshBasicMaterial({ color: 0x696969 });
                const roadV = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH_V, ROAD_LENGTH), roadMat);
                roadV.rotation.x = -Math.PI / 2; scene.add(roadV);
                const roadH = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LENGTH, ROAD_WIDTH_H), roadMat);
                roadH.rotation.x = -Math.PI / 2; scene.add(roadH);

                const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const createStopLine = (w, h, x, z) => {
                    const line = new THREE.Mesh(new THREE.PlaneGeometry(w, h), stopLineMat);
                    line.rotation.x = -Math.PI / 2; line.position.set(x, 0.01, z); scene.add(line);
                };
                createStopLine(LANE_WIDTH_V, 1.5, -LANE_CENTER_V, STOP_LINE_N);
                createStopLine(LANE_WIDTH_V, 1.5, LANE_CENTER_V, STOP_LINE_S);
                createStopLine(1.5, LANE_WIDTH_H, STOP_LINE_E, -LANE_CENTER_H);
                createStopLine(1.5, LANE_WIDTH_H, STOP_LINE_W, LANE_CENTER_H);

                const yellow = new THREE.MeshBasicMaterial({ color: 0xfacc15 });
                const createMedian = (w, h, x, z, rotation) => {
                    const group = new THREE.Group();
                    const body = new THREE.Mesh(new THREE.PlaneGeometry(w, h), yellow);
                    group.add(body);
                    const cap1 = new THREE.Mesh(new THREE.CircleGeometry(w/2, 32), yellow);
                    cap1.position.y = h/2;
                    group.add(cap1);
                    const cap2 = new THREE.Mesh(new THREE.CircleGeometry(w/2, 32), yellow);
                    cap2.position.y = -h/2;
                    group.add(cap2);
                    
                    group.rotation.x = -Math.PI / 2;
                    group.rotation.z = rotation;
                    group.position.set(x, 0.02, z);
                    scene.add(group);
                };
                
                const segLenV = ROAD_LENGTH/2 - ROAD_WIDTH_H/2;
                createMedian(MEDIAN_WIDTH, segLenV, 0, -ROAD_WIDTH_H/2 - segLenV/2, 0);
                createMedian(MEDIAN_WIDTH, segLenV, 0, ROAD_WIDTH_H/2 + segLenV/2, 0);
                const segLenH = ROAD_LENGTH/2 - ROAD_WIDTH_V/2;
                createMedian(MEDIAN_WIDTH, segLenH, -ROAD_WIDTH_V/2 - segLenH/2, 0, Math.PI/2);
                createMedian(MEDIAN_WIDTH, segLenH, ROAD_WIDTH_V/2 + segLenH/2, 0, Math.PI/2);
            }

             function createDashedBorders() {
                const mat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 2, gapSize: 2 });
                const createBorder = (points) => {
                    const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.01, p[1])));
                    const line = new THREE.Line(geo, mat);
                    line.computeLineDistances();
                    scene.add(line);
                };
                const LV = ROAD_LENGTH/2; const LH = ROAD_LENGTH/2;
                const WV = ROAD_WIDTH_V/2; const WH = ROAD_WIDTH_H/2;
                createBorder([[-WV, -LV], [-WV, -WH]]); createBorder([[WV, -LV], [WV, -WH]]);
                createBorder([[-WV, LV], [-WV, WH]]); createBorder([[WV, LV], [WV, WH]]);
                createBorder([[-LH, -WH], [-WV, -WH]]); createBorder([[-LH, WH], [-WV, WH]]);
                createBorder([[LH, -WH], [WV, -WH]]); createBorder([[LH, WH], [WV, WH]]);
            }

            function createMedianBorders() {
                const mat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 1, gapSize: 1.5 });
                const createBorder = (points) => {
                    const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.025, p[1])));
                    const line = new THREE.Line(geo, mat);
                    line.computeLineDistances();
                    scene.add(line);
                };
                const MW_HALF = MEDIAN_WIDTH / 2;
                const WH_HALF = ROAD_WIDTH_H / 2;
                const WV_HALF = ROAD_WIDTH_V / 2;
                const RL_HALF = ROAD_LENGTH / 2;

                createBorder([[-MW_HALF, -WH_HALF], [-MW_HALF, -RL_HALF]]);
                createBorder([[MW_HALF, -WH_HALF], [MW_HALF, -RL_HALF]]);
                createBorder([[-MW_HALF, WH_HALF], [-MW_HALF, RL_HALF]]);
                createBorder([[MW_HALF, WH_HALF], [MW_HALF, RL_HALF]]);
                createBorder([[-WV_HALF, -MW_HALF], [-RL_HALF, -MW_HALF]]);
                createBorder([[-WV_HALF, MW_HALF], [-RL_HALF, MW_HALF]]);
                createBorder([[WV_HALF, -MW_HALF], [RL_HALF, -MW_HALF]]);
                createBorder([[WV_HALF, MW_HALF], [RL_HALF, MW_HALF]]);
            }

            function createLaneMarkings() {
                const mat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 3, gapSize: 5, linewidth: 1 });
                const createLine = (points) => {
                    const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.03, p[1])));
                    const line = new THREE.Line(geo, mat);
                    line.computeLineDistances();
                    scene.add(line);
                };

                const RL_HALF = ROAD_LENGTH / 2;
                const WH_HALF = ROAD_WIDTH_H / 2;
                const WV_HALF = ROAD_WIDTH_V / 2;

                createLine([[LANE_CENTER_V, RL_HALF], [LANE_CENTER_V, WH_HALF]]);
                createLine([[-LANE_CENTER_V, -RL_HALF], [-LANE_CENTER_V, -WH_HALF]]);
                createLine([[-RL_HALF, LANE_CENTER_H], [-WV_HALF, LANE_CENTER_H]]);
                createLine([[RL_HALF, -LANE_CENTER_H], [WV_HALF, -LANE_CENTER_H]]);
                createLine([[LANE_CENTER_V, -WH_HALF], [LANE_CENTER_V, -RL_HALF]]);
                createLine([[-LANE_CENTER_V, WH_HALF], [-LANE_CENTER_V, RL_HALF]]);
                createLine([[WV_HALF, LANE_CENTER_H], [RL_HALF, LANE_CENTER_H]]);
                createLine([[-WV_HALF, -LANE_CENTER_H], [-RL_HALF, -LANE_CENTER_H]]);
            }
            
            function createSensorVisuals() {
                const mat = new THREE.MeshBasicMaterial({ color: 0x00bcd4, transparent: true, opacity: 0.35 }); 
                const createSensor = (w, h, x, z, name) => {
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
                    mesh.rotation.x = -Math.PI/2; 
                    mesh.position.set(x, 0.03, z); 
                    scene.add(mesh);
                    
                    const target = new THREE.Object3D(); 
                    target.name = `target${name}`;
                    
                    const UI_COUNTER_OFFSET = 18;
                    let targetX = x, targetZ = z;

                    if (name === 'A1') targetX -= UI_COUNTER_OFFSET;
                    if (name === 'A5') targetX += UI_COUNTER_OFFSET;
                    if (name === 'A3') targetZ -= UI_COUNTER_OFFSET;
                    if (name === 'A7') targetZ += UI_COUNTER_OFFSET;

                    target.position.set(targetX, 0, targetZ); 
                    scene.add(target);
                };
                createSensor(LANE_WIDTH_V, SENSOR_ZONE_LEN, -LANE_CENTER_V, STOP_LINE_N - SENSOR_ZONE_LEN/2, 'A1');
                createSensor(LANE_WIDTH_V, SENSOR_ZONE_LEN, LANE_CENTER_V, STOP_LINE_S + SENSOR_ZONE_LEN/2, 'A5');
                createSensor(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_E + SENSOR_ZONE_LEN/2, -LANE_CENTER_H, 'A3');
                createSensor(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_W - SENSOR_ZONE_LEN/2, LANE_CENTER_H, 'A7');
            }

            function createStreetLabels(font) {
                const mat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const create = (text, x, z, rot=0) => {
                    const geo = new THREE.TextGeometry(text, { font: font, size: 3, height: 0.1 }); geo.center();
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.x = -Math.PI/2;
                    mesh.rotation.z = rot;
                    mesh.position.set(x, 0.1, z);
                    scene.add(mesh);
                };
                const WV = ROAD_WIDTH_V/2; const WH = ROAD_WIDTH_H/2;
                
                // Entrances
                create('A1', -LANE_CENTER_V, -WH-8); 
                create('A3', WV+8, -LANE_CENTER_H, -Math.PI/2);
                create('A5', LANE_CENTER_V, WH+8);
                create('A7', -WV-8, LANE_CENTER_H, Math.PI/2);

                // Exits
                create('A2', LANE_CENTER_V, -WH-8);
                create('A4', WV+8, LANE_CENTER_H, -Math.PI/2);
                create('A6', -LANE_CENTER_V, WH+8);
                create('A8', -WV-8, -LANE_CENTER_H, Math.PI/2);
            }
            
            function createVehicleMesh(vehicleType, color, width, length) {
                const grp = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: color });
                const darkMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

                if (vehicleType.name === 'CAR') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(width, 1.5, length), mat);
                    body.position.y = 0.75;
                    grp.add(body);
                    const top = new THREE.Mesh(new THREE.BoxGeometry(width * 0.85, 0.8, length * 0.55), darkMat);
                    top.position.set(0, 1.9, -0.2);
                    grp.add(top);
                } else if (vehicleType.name === 'TRUCK') {
                    const cab = new THREE.Mesh(new THREE.BoxGeometry(width, 2.2, length * 0.4), mat);
                    cab.position.set(0, 1.1, length * 0.3);
                    grp.add(cab);
                    const trailer = new THREE.Mesh(new THREE.BoxGeometry(width * 0.95, 2.5, length * 0.65), darkMat);
                    trailer.position.set(0, 1.25, -length * 0.175);
                    grp.add(trailer);
                } else if (vehicleType.name === 'MOTORCYCLE') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(width, 0.8, length), mat);
                    body.position.y = 0.6;
                    grp.add(body);
                    const seat = new THREE.Mesh(new THREE.BoxGeometry(width * 0.8, 0.4, length * 0.4), darkMat);
                    seat.position.set(0, 1.2, -length * 0.1);
                    grp.add(seat);
                }
                
                // Lights
                const headLightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                const tailLightMat = new THREE.MeshBasicMaterial({ color: 0xdd0000 });
                const lightY = 0.85;
                const lightWidth = Math.max(0.2, width * 0.2);

                const leftHeadLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), headLightMat);
                leftHeadLight.position.set(-width / 2.5, lightY, length / 2 + 0.01);
                grp.add(leftHeadLight);

                const rightHeadLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), headLightMat);
                rightHeadLight.position.set(width / 2.5, lightY, length / 2 + 0.01);
                grp.add(rightHeadLight);

                const leftTailLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), tailLightMat);
                leftTailLight.position.set(-width / 2.5, lightY, -length / 2 - 0.01);
                grp.add(leftTailLight);
                
                const rightTailLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), tailLightMat);
                rightTailLight.position.set(width / 2.5, lightY, -length / 2 - 0.01);
                grp.add(rightTailLight);

                return grp;
            }
            
            function startTurn(c) {
                c.isTurning = true;
                c.wantsToTurn = false;
                c.turnProgress = 0;

                const W_V_HALF = ROAD_WIDTH_V / 2;
                const W_H_HALF = ROAD_WIDTH_H / 2;

                let start, end, control;

                // Note: Directions are named based on destination, not origin
                // NORTH: Northbound (from A5), SOUTH: Southbound (from A1) etc.
                switch(c.direction) {
                    case Direction.SOUTH: // A1 -> A8 (Southbound to Westbound)
                        start = new THREE.Vector3(-LANE_CENTER_V - LANE_OFFSET, 0, -W_H_HALF);
                        end = new THREE.Vector3(-W_V_HALF, 0, -LANE_CENTER_H - LANE_OFFSET);
                        control = new THREE.Vector3(start.x, 0, end.z);
                        break;
                    case Direction.WEST: // A3 -> A2 (Westbound to Northbound)
                        start = new THREE.Vector3(W_V_HALF, 0, -LANE_CENTER_H - LANE_OFFSET);
                        end = new THREE.Vector3(LANE_CENTER_V + LANE_OFFSET, 0, -W_H_HALF);
                        control = new THREE.Vector3(end.x, 0, start.z);
                        break;
                    case Direction.NORTH: // A5 -> A4 (Northbound to Eastbound)
                        start = new THREE.Vector3(LANE_CENTER_V + LANE_OFFSET, 0, W_H_HALF);
                        end = new THREE.Vector3(W_V_HALF, 0, LANE_CENTER_H + LANE_OFFSET);
                        control = new THREE.Vector3(start.x, 0, end.z);
                        break;
                    case Direction.EAST: // A7 -> A6 (Eastbound to Southbound)
                        start = new THREE.Vector3(-W_V_HALF, 0, LANE_CENTER_H + LANE_OFFSET);
                        end = new THREE.Vector3(-LANE_CENTER_V - LANE_OFFSET, 0, W_H_HALF);
                        control = new THREE.Vector3(end.x, 0, start.z);
                        break;
                }
                
                if (start && end && control) {
                    c.turnPath = new THREE.QuadraticBezierCurve3(start, control, end);
                    c.mesh.position.copy(start);
                } else {
                    c.isTurning = false;
                    c.destinationDirection = null;
                }
            }

            function updateTurn(c, dt) {
                if (!c.turnPath) {
                    c.isTurning = false; return;
                }

                const turnSpeedFactor = 0.8;
                const distanceToMove = c.speed * dt * turnSpeedFactor;
                const pathLength = c.turnPath.getLength();
                const progressIncrement = distanceToMove / pathLength;
                c.turnProgress += progressIncrement;

                if (c.turnProgress >= 1) {
                    c.isTurning = false;
                    const endPoint = c.turnPath.getPointAt(1);
                    c.mesh.position.copy(endPoint);
                    c.direction = c.destinationDirection;
                    c.destinationDirection = null;
                    c.turnPath = null;
                    
                    // Update rotation to match new direction
                    switch(c.direction) {
                        case Direction.NORTH: c.mesh.rotation.y = Math.PI; break;    // Northbound faces -Z
                        case Direction.EAST: c.mesh.rotation.y = Math.PI/2; break;   // Eastbound faces +X
                        case Direction.SOUTH: c.mesh.rotation.y = 0; break;           // Southbound faces +Z
                        case Direction.WEST: c.mesh.rotation.y = -Math.PI/2; break;  // Westbound faces -X
                    }
                } else {
                    const newPos = c.turnPath.getPointAt(c.turnProgress);
                    const tangent = c.turnPath.getTangentAt(c.turnProgress).normalize();
                    c.mesh.position.copy(newPos);
                    c.mesh.rotation.y = Math.atan2(tangent.x, tangent.z); // Adjust for vehicle model orientation
                }
            }
            
            function spawnVehicle() {
                const rand = Math.random();
                let vehicleType;
                if (rand < 0.7) vehicleType = VEHICLE_TYPES.CAR;
                else if (rand < 0.85) vehicleType = VEHICLE_TYPES.TRUCK;
                else vehicleType = VEHICLE_TYPES.MOTORCYCLE;

                const lengthMultiplier = 0.9 + Math.random() * 0.2;
                const widthMultiplier = 0.95 + Math.random() * 0.1;
                const actualLength = vehicleType.baseLength * lengthMultiplier;
                const actualWidth = vehicleType.baseWidth * widthMultiplier;

                const vehicle = { 
                    mesh: null, 
                    direction: null, 
                    speed: 0, 
                    maxSpeed: vehicleType.maxSpeed[0] + Math.random() * vehicleType.maxSpeed[1],
                    acceleration: vehicleType.acceleration[0] + Math.random() * vehicleType.acceleration[1],
                    followingTime: 0.8 + Math.random() * 0.7,
                    actualLength: actualLength,
                    type: vehicleType.name,
                    wantsToTurn: false,
                    isTurning: false,
                    turnPath: null,
                    turnProgress: 0,
                    destinationDirection: null,
                };

                const canTurn = vehicle.type === 'CAR' || vehicle.type === 'MOTORCYCLE';
                if (canTurn && Math.random() < 0.35) {
                    vehicle.wantsToTurn = true;
                }

                let x = 0, z = 0, rot = 0;
                const L = ROAD_LENGTH / 2 + 10;
                
                // Note: Directions are named based on destination, not origin
                // A1: Southbound, A3: Westbound, A5: Northbound, A7: Eastbound
                switch(Math.floor(Math.random() * 4)) {
                    case 0: // From A1 (Southbound)
                        vehicle.direction = Direction.SOUTH; 
                        rot = 0; // Faces +Z
                        z = -L;
                        if (vehicle.wantsToTurn) { // A1 -> A8 (to Westbound)
                            x = -LANE_CENTER_V - LANE_OFFSET; // Outer lane for right turn
                            vehicle.destinationDirection = Direction.WEST;
                        } else {
                            x = (Math.random() < 0.5 ? -LANE_CENTER_V - LANE_OFFSET : -LANE_CENTER_V + LANE_OFFSET); 
                        }
                        break;
                    case 1: // From A3 (Westbound)
                        vehicle.direction = Direction.WEST;
                        rot = -Math.PI/2; // Faces -X
                        x = L;
                        if (vehicle.wantsToTurn) { // A3 -> A2 (to Northbound)
                            z = -LANE_CENTER_H - LANE_OFFSET; // Outer lane
                            vehicle.destinationDirection = Direction.NORTH;
                        } else {
                             z = (Math.random() < 0.5 ? -LANE_CENTER_H - LANE_OFFSET : -LANE_CENTER_H + LANE_OFFSET); 
                        }
                        break;
                    case 2: // From A5 (Northbound)
                        vehicle.direction = Direction.NORTH;
                        rot = Math.PI; // Faces -Z
                        z = L;
                        if (vehicle.wantsToTurn) { // A5 -> A4 (to Eastbound)
                            x = LANE_CENTER_V + LANE_OFFSET; // Outer lane
                            vehicle.destinationDirection = Direction.EAST;
                        } else {
                            x = (Math.random() < 0.5 ? LANE_CENTER_V - LANE_OFFSET : LANE_CENTER_V + LANE_OFFSET); 
                        }
                        break;
                    case 3: // From A7 (Eastbound)
                        vehicle.direction = Direction.EAST;
                        rot = Math.PI/2; // Faces +X
                        x = -L;
                        if (vehicle.wantsToTurn) { // A7 -> A6 (to Southbound)
                           z = LANE_CENTER_H + LANE_OFFSET; // Outer lane
                           vehicle.destinationDirection = Direction.SOUTH;
                        } else {
                            z = (Math.random() < 0.5 ? LANE_CENTER_H - LANE_OFFSET : LANE_CENTER_H + LANE_OFFSET); 
                        }
                        break;
                }

                if (cars.some(c => c.mesh.position.distanceTo(new THREE.Vector3(x,0,z)) < c.actualLength * 2.5)) return;
                
                const color = vehicleType.colorPool[Math.floor(Math.random() * vehicleType.colorPool.length)];
                const mesh = createVehicleMesh(vehicleType, color, actualWidth, actualLength);

                mesh.position.set(x, 0, z); mesh.rotation.y = rot; scene.add(mesh);
                vehicle.mesh = mesh; vehicle.speed = vehicle.maxSpeed; cars.push(vehicle);
            }

            function updateCars(dt) {
                for (let i = cars.length - 1; i >= 0; i--) {
                    const c = cars[i];
                    if (!c.mesh) { cars.splice(i, 1); continue; }

                    if (c.isTurning) {
                        updateTurn(c, dt);
                        continue;
                    }

                    if (Math.abs(c.mesh.position.x) > ROAD_LENGTH / 2 + 20 || Math.abs(c.mesh.position.z) > ROAD_LENGTH / 2 + 20) {
                        scene.remove(c.mesh); cars.splice(i, 1); continue;
                    }

                    let targetSpeed = c.maxSpeed;
                    const carLength = c.actualLength;

                    let minGap = Infinity;
                    let frontCar = null;
                    cars.forEach(o => {
                        if (c === o || c.isTurning || o.isTurning || c.direction !== o.direction) return;
                        
                        // Solo considerar vehículos en el mismo carril
                        if (c.direction === Direction.SOUTH || c.direction === Direction.NORTH) { // Vertical
                            if (Math.abs(c.mesh.position.x - o.mesh.position.x) > 1) return;
                        } else { // Horizontal
                            if (Math.abs(c.mesh.position.z - o.mesh.position.z) > 1) return;
                        }

                        let gap;
                        if (c.direction === Direction.SOUTH)      gap = o.mesh.position.z - c.mesh.position.z; // Southbound (+z)
                        else if (c.direction === Direction.NORTH) gap = c.mesh.position.z - o.mesh.position.z; // Northbound (-z)
                        else if (c.direction === Direction.WEST)  gap = c.mesh.position.x - o.mesh.position.x; // Westbound (-x)
                        else if (c.direction === Direction.EAST)  gap = o.mesh.position.x - c.mesh.position.x; // Eastbound (+x)
                        
                        if (gap > 0 && gap < minGap) {
                            minGap = gap;
                            frontCar = o;
                        }
                    });
                    
                    if (frontCar) {
                        const stoppingGap = (carLength / 2) + (frontCar.actualLength / 2) + 2.5; 
                        const safeFollowingDistance = stoppingGap + c.speed * c.followingTime;

                        if (minGap < safeFollowingDistance) {
                            targetSpeed = minGap < stoppingGap ? 0 : c.maxSpeed * ((minGap - stoppingGap) / (safeFollowingDistance - stoppingGap));
                        }
                    }

                    let light, stopLine, pos, distStop;
                    if (c.direction === Direction.SOUTH)      { light = controller.stateV; stopLine = STOP_LINE_N; pos = c.mesh.position.z; distStop = stopLine - pos; }
                    else if (c.direction === Direction.NORTH) { light = controller.stateV; stopLine = STOP_LINE_S; pos = c.mesh.position.z; distStop = pos - stopLine; }
                    else if (c.direction === Direction.EAST)  { light = controller.stateH; stopLine = STOP_LINE_W; pos = c.mesh.position.x; distStop = stopLine - pos; }
                    else if (c.direction === Direction.WEST)  { light = controller.stateH; stopLine = STOP_LINE_E; pos = c.mesh.position.x; distStop = pos - stopLine; }
                    
                    const frontBumperDist = distStop - carLength / 2;

                    // --- Turn Logic ---
                    let canTurn = light === LightState.GREEN;
                    if(c.wantsToTurn) {
                        const turnTriggerDist = 1; 
                        if ( (c.direction === Direction.SOUTH && c.mesh.position.z > -ROAD_WIDTH_H/2 - turnTriggerDist) ||
                             (c.direction === Direction.NORTH && c.mesh.position.z <  ROAD_WIDTH_H/2 + turnTriggerDist) ||
                             (c.direction === Direction.EAST  && c.mesh.position.x > -ROAD_WIDTH_V/2 - turnTriggerDist) ||
                             (c.direction === Direction.WEST  && c.mesh.position.x <  ROAD_WIDTH_V/2 + turnTriggerDist) ) 
                        {
                            if (canTurn) {
                                startTurn(c);
                                continue;
                            }
                        }
                    }

                    const mustStopForLight = !canTurn && distStop > 0;
                    if (mustStopForLight && frontBumperDist < 60) {
                        let desiredSpeed = frontBumperDist * 1.5;
                        if (desiredSpeed < 0) desiredSpeed = 0;
                        targetSpeed = Math.min(targetSpeed, desiredSpeed);
                    }

                    const smoothingFactor = mustStopForLight ? 0.3 : c.acceleration;
                    c.speed += (targetSpeed - c.speed) * smoothingFactor;
                    if (c.speed < 0) c.speed = 0;

                    let movement = c.speed * dt;

                    const COLLISION_BUFFER = 2.5;
                    const BRAKE_BUFFER = 1.5;
                    let maxMovementFromCar = Infinity;
                    if (frontCar) {
                        maxMovementFromCar = minGap - (carLength / 2) - (frontCar.actualLength / 2) - COLLISION_BUFFER;
                    }
                    
                    let maxMovementFromLight = Infinity;
                    if (mustStopForLight) maxMovementFromLight = frontBumperDist - BRAKE_BUFFER;
                    
                    const maxSafeMovement = Math.min(maxMovementFromCar, maxMovementFromLight);
                    if (movement > maxSafeMovement) {
                        movement = Math.max(0, maxSafeMovement);
                        c.speed = 0;
                    }
                    
                    c.mesh.translateZ(movement); 
                }
            }

            function updateCounters() {
                const counts = { a1: 0, a3: 0, a5: 0, a7: 0 };
                cars.forEach(c => {
                    const { x, z } = c.mesh.position;
                    if (!c.isTurning) {
                         if (c.direction === Direction.SOUTH && z > (STOP_LINE_N - SENSOR_ZONE_LEN) && z < STOP_LINE_N) counts.a1++;
                         if (c.direction === Direction.NORTH && z < (STOP_LINE_S + SENSOR_ZONE_LEN) && z > STOP_LINE_S) counts.a5++;
                         if (c.direction === Direction.WEST && x < (STOP_LINE_E + SENSOR_ZONE_LEN) && x > STOP_LINE_E) counts.a3++;
                         if (c.direction === Direction.EAST && x > (STOP_LINE_W - SENSOR_ZONE_LEN) && x < STOP_LINE_W) counts.a7++;
                    }
                });
                Object.keys(counts).forEach(k => { if (counters[k] && counters[k].val) counters[k].val.innerText = counts[k]; });
                return counts;
            }

            function updateUIProject() {
                const updatePos = (name, el) => {
                    const obj = scene.getObjectByName(`target${name}`);
                    if (!obj) return;
                    const v = new THREE.Vector3(); obj.getWorldPosition(v); v.project(camera);
                    el.style.left = `${(v.x * .5 + .5) * window.innerWidth}px`;
                    el.style.top = `${(v.y * -.5 + .5) * window.innerHeight}px`;
                };
                Object.keys(counters).forEach(k => updatePos(k.toUpperCase(), counters[k].el));
            }

            function animate() {
                requestAnimationFrame(animate);
                const dt = clock.getDelta() * SIMULATION_SPEED;
                const elapsedTime = clock.getElapsedTime() * SIMULATION_SPEED;

                if (elapsedTime > nextSpawnTime && cars.length < 150) {
                    spawnVehicle();
                    const baseInterval = (1.0 - (density / 100 * 0.9)) * 2.5;
                    const randomInterval = baseInterval * (0.5 + Math.random() * 1.0);
                    nextSpawnTime = elapsedTime + randomInterval;
                }
                
                updateCars(dt);
                const counts = updateCounters();
                controller.updateLogic(dt, counts);
                updateUIProject();
                renderer.render(scene, camera);
            }

            function onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 80;
                camera.left = -d * aspect; camera.right = d * aspect;
                camera.top = d; camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            init();
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>