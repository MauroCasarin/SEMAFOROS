<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación Tráfico WebGL - Vanilla JS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (Global CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Contadores Flotantes (UI) */
        .sensor-counter {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #22d3ee; /* cyan-400 */
            border: 2px solid #06b6d4; /* cyan-500 */
            font-size: 1.8rem;
            font-weight: bold;
            padding: 0.5rem 1.0rem;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 60px;
        }
        .sensor-label {
            display: block;
            font-size: 0.6rem;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: -2px;
        }
        
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.95);
            border: 1px solid #374151;
            backdrop-filter: blur(4px);
        }
    </style>
<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@^0.182.0",
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.34.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>

    <!-- UI: Contadores Flotantes -->
    <div id="counter-v" class="sensor-counter">
        <span id="val-v">0</span>
        <span class="sensor-label">Norte</span>
    </div>
    <div id="counter-h" class="sensor-counter">
        <span id="val-h">0</span>
        <span class="sensor-label">Oeste</span>
    </div>

    <!-- UI: Controles -->
    <div class="absolute bottom-6 left-6 right-6 flex flex-col md:flex-row justify-between items-end gap-4 pointer-events-none z-20">
        
        <!-- Slider Densidad -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto w-full md:w-72">
            <label class="block text-sm font-bold mb-2 text-cyan-400 flex justify-between">
                <span>Densidad Tráfico</span>
                <span id="density-val">50%</span>
            </label>
            <input id="density-slider" type="range" min="1" max="100" value="50" 
                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
        </div>

        <!-- Botón Modo -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto flex items-center gap-4">
            <div>
                <p class="text-xs text-gray-400 mb-1 uppercase tracking-wider">Estado</p>
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></div>
                    <span id="status-text" class="font-bold text-sm">INTELIGENTE</span>
                </div>
            </div>
            <button id="mode-btn" 
                    class="px-4 py-2 rounded font-bold transition-all bg-cyan-600 hover:bg-cyan-500 text-white shadow text-sm border-b-2 border-cyan-800 active:border-b-0 active:translate-y-0.5">
                Cambiar Modo
            </button>
        </div>
    </div>

    <!-- Lógica Principal -->
    <script>
        window.onload = function() {
            
            // --- CONFIGURACIÓN ---
            const ROAD_WIDTH = 22;
            const ROAD_LENGTH = 220; 
            const LANE_WIDTH = ROAD_WIDTH / 4; // 5.5
            const SIMULATION_SPEED = 0.3; // Velocidad de simulación
            
            // Dimensiones de las sendas peatonales (pasos de cebra)
            const STRIPE_DEPTH = 1.0; // Profundidad de cada franja blanca
            const GAP_BETWEEN_STRIPES = 0.5; // Espacio entre las franjas blancas
            const NUM_STRIPES = 6; // Número de franjas por paso de cebra
            const TOTAL_CROSSWALK_LENGTH = NUM_STRIPES * STRIPE_DEPTH + (NUM_STRIPES - 1) * GAP_BETWEEN_STRIPES; // 6 * 1.0 + 5 * 0.5 = 8.5

            // Ajuste: las líneas de detención se mueven para estar JUSTO ANTES de los pasos de cebra.
            const STOP_LINE_V = ROAD_WIDTH / 2 + 10; // 11 + 10 = 21
            const STOP_LINE_H = ROAD_WIDTH / 2 + 10; // 11 + 10 = 21

            // --- AQUI EL CAMBIO: SENSOR_ZONE_POS AHORA SE CALCULA PARA QUE SU FINAL COINCIDA CON LA LÍNEA DE DETENCIÓN ---
            const SENSOR_ZONE_LEN = 40; // Longitud de la zona de detección
            const SENSOR_ZONE_POS = STOP_LINE_V + SENSOR_ZONE_LEN / 2; // El centro de la zona de detección se mueve para que su borde más cercano esté en STOP_LINE_V

            const CAR_LENGTH = 4.5;
            const SAFETY_GAP = 4.0; 

            // Enumeraciones
            const Street = { VERTICAL: 'VERTICAL', HORIZONTAL: 'HORIZONTAL' };
            const LightState = { RED: 'RED', YELLOW: 'YELLOW', GREEN: 'GREEN' };

            // Variables Globales
            let scene, camera, renderer, clock;
            let cars = [];
            let density = 50;
            let isSmartMode = true;
            let controller;

            // Elementos DOM
            const elCounterV = document.getElementById('counter-v');
            const elCounterH = document.getElementById('counter-h');
            const elValV = document.getElementById('val-v');
            const elValH = document.getElementById('val-h');
            const elDensityVal = document.getElementById('density-val');
            const elStatusText = document.getElementById('status-text');
            const elStatusDot = document.getElementById('status-dot');
            
            // --- CLASE: Controlador de Semáforos ---
            class TrafficController {
                constructor(scene) {
                    this.stateV = LightState.GREEN; // Cambiado: Ahora la calle Vertical empieza en Verde
                    this.stateH = LightState.RED;    // Cambiado: Ahora la calle Horizontal (Oeste) empieza en Rojo
                    this.timerV = 0;
                    this.timerH = 0;
                    this.cycleTimer = 0;
                    this.transitioning = false;
                    this.flashTimerV = 0; // Temporizador para el flasheo de la luz amarilla vertical
                    this.flashTimerH = 0; // Temporizador para el flasheo de la luz amarilla horizontal

                    // Tiempos (segundos simulados)
                    this.MIN_GREEN = 3.0; // Más rápido
                    this.MAX_GREEN = 12.0;
                    this.YELLOW_TIME = 1.0; // Más rápido
                    this.FIXED_TIME = 5.0; // Más rápido

                    this.buildInfrastructure(scene); 
                    this.updateVisuals(0); // Pasa 0 para la inicialización          
                }

                buildInfrastructure(scene) {
                    // Luz un poco más grande
                    const createBulb = () => new THREE.Mesh(
                        new THREE.SphereGeometry(2.0, 16, 16), // Incrementado de 1.5 a 2.0
                        new THREE.MeshBasicMaterial({ color: 0x111111 }) 
                    );

                    // Función para crear un semáforo detallado con un solo foco cambiante
                    const createDetailedTrafficLight = (x, z, rotation) => {
                        const group = new THREE.Group();
                        
                        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.5 });
                        const poleHeight = 25; 
                        
                        // Poste (Cilindro)
                        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, poleHeight, 16), matBlack); 
                        pole.position.y = poleHeight / 2;
                        pole.castShadow = true;
                        group.add(pole);

                        // Carcasa principal del semáforo
                        const housingWidth = 5;
                        const housingHeight = 10; // Altura más compacta para un solo foco
                        const housingDepth = 3;

                        const housing = new THREE.Mesh(new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth), matBlack);
                        housing.position.set(0, poleHeight - 2 - (housingHeight / 2), 0.5); 
                        housing.castShadow = true;
                        group.add(housing);

                        // Única luz central
                        const bulbZPos = housingDepth / 2 + 0.5; 
                        const mainLight = createBulb(); 
                        mainLight.position.set(0, 0, -bulbZPos); // Centrada verticalmente en la carcasa
                        housing.add(mainLight);

                        // Visor alrededor de la luz
                        const visorGeo = new THREE.BoxGeometry(housingWidth + 0.5, 0.5, 2.5); 
                        const visorMat = matBlack;
                        const visorZPos = housingDepth / 2 + 0.2; 
                        const visorYOffset = 2.5; // Offset desde el centro de la bombilla hasta la parte inferior del visor

                        const mainVisor = new THREE.Mesh(visorGeo, visorMat);
                        mainVisor.position.set(0, mainLight.position.y + visorYOffset, -visorZPos);
                        housing.add(mainVisor);
                        
                        group.position.set(x, 0, z);
                        group.rotation.y = rotation; 
                        scene.add(group);

                        return mainLight; // Retorna la luz principal para control de color
                    };

                    // Semáforo Vertical (Tráfico desde Norte a Sur) - Posición "fuera de la calle", a la derecha
                    // Más al Este y más al Norte de la intersección.
                    // Rotación cambiada a Math.PI para que apunte al Norte (dirección +Z)
                    this.lightsV = createDetailedTrafficLight(ROAD_WIDTH / 2 + 2, ROAD_WIDTH / 2 + 3, Math.PI); 
                    // Semáforo Horizontal (Tráfico desde Este a Oeste) - Posición "fuera de la calle", a la derecha
                    // Más al Este y más al Sur de la intersección.
                    this.lightsH = createDetailedTrafficLight(ROAD_WIDTH / 2 + 3, -ROAD_WIDTH / 2 - 2, -Math.PI / 2);
                }

                // Método para establecer el color de la luz del semáforo, incluyendo flasheo
                setLightColor(mesh, state, flashTimer) {
                    let colorHex = 0x222222; // Color 'apagado' por defecto
                    const FLASH_RATE = 5; // Frecuencia de flasheo en Hz (5 veces por segundo)

                    if (state === LightState.RED) colorHex = 0xff0000;
                    else if (state === LightState.GREEN) colorHex = 0x00ff00;
                    else if (state === LightState.YELLOW) {
                        // Lógica de flasheo para el amarillo
                        if (Math.floor(flashTimer * FLASH_RATE) % 2 === 0) {
                            colorHex = 0xffaa00; // Amarillo
                        } else {
                            colorHex = 0x222222; // Apagado
                        }
                    }
                    mesh.material.color.setHex(colorHex);
                }

                updateVisuals() {
                    // Actualiza el color del foco único del semáforo vertical
                    this.setLightColor(this.lightsV, this.stateV, this.flashTimerV);
                    // Actualiza el color del foco único del semáforo horizontal
                    this.setLightColor(this.lightsH, this.stateH, this.flashTimerH);
                }

                switchLight(targetStreet) {
                    if (this.transitioning) return;
                    
                    if (targetStreet === Street.VERTICAL && this.stateV === LightState.GREEN) return;
                    if (targetStreet === Street.HORIZONTAL && this.stateH === LightState.GREEN) return;

                    this.transitioning = true;
                    
                    // Fase Amarillo para la calle que estaba en verde
                    if (this.stateV === LightState.GREEN) {
                        this.stateV = LightState.YELLOW;
                        this.flashTimerV = 0; // Reinicia el temporizador de flasheo
                    }
                    if (this.stateH === LightState.GREEN) {
                        this.stateH = LightState.YELLOW;
                        this.flashTimerH = 0; // Reinicia el temporizador de flasheo
                    }
                    this.updateVisuals(); 

                    setTimeout(() => {
                        this.stateV = LightState.RED;
                        this.stateH = LightState.RED;
                        
                        if (targetStreet === Street.VERTICAL) this.stateV = LightState.GREEN;
                        else this.stateH = LightState.GREEN;
                        
                        this.timerV = 0;
                        this.timerH = 0;
                        this.transitioning = false;
                        this.updateVisuals(); 
                    }, this.YELLOW_TIME * 1000 / SIMULATION_SPEED);
                }

                updateLogic(dt, countV, countH) {
                    if (this.transitioning) return;

                    if (this.stateV === LightState.GREEN) this.timerV += dt;
                    if (this.stateH === LightState.GREEN) this.timerH += dt;

                    // Actualizar flash timers si están en amarillo
                    if (this.stateV === LightState.YELLOW) this.flashTimerV += dt;
                    if (this.stateH === LightState.YELLOW) this.flashTimerH += dt;

                    if (isSmartMode) {
                        // Modo Inteligente: Prioridad por demanda
                        
                        // 1. Tiempo Máximo excedido y hay alguien esperando -> Cambio Forzado
                        if (this.stateV === LightState.GREEN && this.timerV > this.MAX_GREEN && countH > 0) {
                            this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MAX_GREEN && countV > 0) {
                            this.switchLight(Street.VERTICAL);
                        }
                        // 2. Tiempo Mínimo cumplido y la otra calle tiene más autos -> Cambio
                        else if (this.stateV === LightState.GREEN && this.timerV > this.MIN_GREEN) {
                            if (countH > countV) this.switchLight(Street.HORIZONTAL);
                            else if (countH > 0 && countV === 0) this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MIN_GREEN) {
                            if (countV > countH) this.switchLight(Street.VERTICAL);
                            else if (countV > 0 && countH === 0) this.switchLight(Street.VERTICAL);
                        }
                        // 3. Empate o vacío: ciclo lento para no bloquearse
                        else if (countV === 0 && countH === 0) {
                             // Si no hay nadie, mantenemos el verde actual o rotamos muy lento
                             if (this.timerV > 20 || this.timerH > 20) {
                                 this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                             }
                        }
                    } else {
                        // Modo Manual/Cíclico
                        this.cycleTimer += dt;
                        if (this.cycleTimer > this.FIXED_TIME) {
                            this.cycleTimer = 0;
                            this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                        }
                    }
                }
            }

            // --- ESCENA PRINCIPAL ---
            function init() {
                const container = document.getElementById('canvas-container');

                // 1. Escena
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf3f4f6); // Gris muy claro

                // 2. Cámara Cenital (Top-Down)
                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                camera.position.set(0, 100, 0); 
                camera.lookAt(0, 0, 0); 
                camera.rotation.z = Math.PI; // Norte hacia arriba

                // 3. Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                // 4. Iluminación
                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 80, 40);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -60;
                sun.shadow.camera.right = 60;
                sun.shadow.camera.top = 60;
                sun.shadow.camera.bottom = -60;
                scene.add(sun);

                // 5. Mundo
                createRoads();
                createCrosswalks(); // Añadido: Crear sendas peatonales
                createSensorVisuals();
                controller = new TrafficController(scene); 

                // 6. Eventos UI
                window.addEventListener('resize', onResize);
                
                document.getElementById('density-slider').addEventListener('input', (e) => {
                    density = parseInt(e.target.value);
                    elDensityVal.innerText = density + '%';
                });

                document.getElementById('mode-btn').addEventListener('click', (e) => {
                    isSmartMode = !isSmartMode;
                    if(isSmartMode) {
                        elStatusText.innerText = "INTELIGENTE";
                        elStatusDot.classList.remove('bg-orange-500');
                        elStatusDot.classList.add('bg-green-500');
                        elCounterV.style.display = 'block';
                        elCounterH.style.display = 'block';
                    } else {
                        elStatusText.innerText = "MANUAL (Cíclico)";
                        elStatusDot.classList.remove('bg-green-500');
                        elStatusDot.classList.add('bg-orange-500');
                        elCounterV.style.display = 'none';
                        elCounterH.style.display = 'none';
                    }
                });

                // Iniciar Loop
                clock = new THREE.Clock();
                animate();
                
                elCounterV.style.display = 'block';
                elCounterH.style.display = 'block';
            }

            function createRoads() {
                const roadMat = new THREE.MeshPhongMaterial({ color: 0x555555 });
                
                // Calles
                const vRoad = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH), roadMat);
                vRoad.rotation.x = -Math.PI / 2;
                vRoad.receiveShadow = true;
                scene.add(vRoad);

                const hRoad = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LENGTH, ROAD_WIDTH), roadMat);
                hRoad.rotation.x = -Math.PI / 2;
                hRoad.receiveShadow = true;
                scene.add(hRoad);

                const inter = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_WIDTH), roadMat);
                inter.rotation.x = -Math.PI / 2;
                inter.position.y = 0.01;
                inter.receiveShadow = true;
                scene.add(inter);

                // Líneas
                const yellow = new THREE.MeshBasicMaterial({ color: 0xfacc15 });
                const white = new THREE.MeshBasicMaterial({ color: 0xffffff });

                const lineThickness = 0.5; // Grosor para todas las líneas

                // --- 1. Líneas Amarillas Centrales Sólidas ---
                // Longitud de un segmento de línea fuera de la intersección
                const yellowSegmentLength = (ROAD_LENGTH / 2) - (ROAD_WIDTH / 2); 
                // Punto medio de un segmento para posicionarlo
                const yellowMidpointOffset = (ROAD_LENGTH / 2 + ROAD_WIDTH / 2) / 2; 

                // Carreteras verticales (eje Z)
                const yellowLineV_North = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, yellowSegmentLength), yellow);
                yellowLineV_North.rotation.x = -Math.PI / 2;
                yellowLineV_North.position.set(0, 0.02, yellowMidpointOffset);
                scene.add(yellowLineV_North);

                const yellowLineV_South = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, yellowSegmentLength), yellow);
                yellowLineV_South.rotation.x = -Math.PI / 2;
                yellowLineV_South.position.set(0, 0.02, -yellowMidpointOffset);
                scene.add(yellowLineV_South);

                // Carreteras horizontales (eje X)
                const yellowLineH_East = new THREE.Mesh(new THREE.PlaneGeometry(yellowSegmentLength, lineThickness), yellow);
                yellowLineH_East.rotation.x = -Math.PI / 2;
                yellowLineH_East.position.set(yellowMidpointOffset, 0.02, 0);
                scene.add(yellowLineH_East);

                const yellowLineH_West = new THREE.Mesh(new THREE.PlaneGeometry(yellowSegmentLength, lineThickness), yellow);
                yellowLineH_West.rotation.x = -Math.PI / 2;
                yellowLineH_West.position.set(-yellowMidpointOffset, 0.02, 0);
                scene.add(yellowLineH_West);


                // --- 2. Líneas Blancas Discontinuas de Separación de Carriles ---
                // Se eliminó el código que generaba estas líneas para simplificar la señalización.


                // --- 3. Líneas Blancas Exteriores Sólidas (Bordes de la Calzada) ---
                const edgeLineSegmentLength = yellowSegmentLength; // Misma longitud que las líneas amarillas centrales
                const edgeLineMidpointOffset = yellowMidpointOffset; // Mismo punto medio

                // Carreteras verticales (en x = +/- ROAD_WIDTH/2)
                const whiteEdgeLineV_EastNorth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_EastNorth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_EastNorth.position.set(ROAD_WIDTH / 2, 0.02, edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_EastNorth);

                const whiteEdgeLineV_WestNorth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_WestNorth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_WestNorth.position.set(-ROAD_WIDTH / 2, 0.02, edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_WestNorth);

                const whiteEdgeLineV_EastSouth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_EastSouth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_EastSouth.position.set(ROAD_WIDTH / 2, 0.02, -edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_EastSouth);

                const whiteEdgeLineV_WestSouth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_WestSouth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_WestSouth.position.set(-ROAD_WIDTH / 2, 0.02, -edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_WestSouth);


                // Carreteras horizontales (en z = +/- ROAD_WIDTH/2)
                const whiteEdgeLineH_NorthEast = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_NorthEast.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_NorthEast.position.set(edgeLineMidpointOffset, 0.02, ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_NorthEast);

                const whiteEdgeLineH_SouthEast = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_SouthEast.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_SouthEast.position.set(edgeLineMidpointOffset, 0.02, -ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_SouthEast);

                const whiteEdgeLineH_NorthWest = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_NorthWest.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_NorthWest.position.set(-edgeLineMidpointOffset, 0.02, ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_NorthWest);

                const whiteEdgeLineH_SouthWest = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_SouthWest.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_SouthWest.position.set(-edgeLineMidpointOffset, 0.02, -ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_SouthWest);
                
                // Líneas de detención (solid white lines before crosswalks) - Mantenemos estas tal cual
                const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const stopLineGeoV = new THREE.PlaneGeometry(ROAD_WIDTH - 2, 1); // Ancho de carretera - márgenes
                const stopLineGeoH = new THREE.PlaneGeometry(1, ROAD_WIDTH - 2);

                const stopLineV_North = new THREE.Mesh(stopLineGeoV, stopLineMat);
                stopLineV_North.rotation.x = -Math.PI / 2;
                stopLineV_North.position.set(0, 0.02, STOP_LINE_V);
                scene.add(stopLineV_North);

                const stopLineV_South = new THREE.Mesh(stopLineGeoV, stopLineMat);
                stopLineV_South.rotation.x = -Math.PI / 2;
                stopLineV_South.position.set(0, 0.02, -STOP_LINE_V); // Utiliza el valor negativo para la dirección opuesta
                scene.add(stopLineV_South);

                const stopLineH_East = new THREE.Mesh(stopLineGeoH, stopLineMat);
                stopLineH_East.rotation.x = -Math.PI / 2;
                stopLineH_East.position.set(STOP_LINE_H, 0.02, 0);
                scene.add(stopLineH_East);

                const stopLineH_West = new THREE.Mesh(stopLineGeoH, stopLineMat);
                stopLineH_West.rotation.x = -Math.PI / 2;
                stopLineH_West.position.set(-STOP_LINE_H, 0.02, 0); // Utiliza el valor negativo para la dirección opuesta
                scene.add(stopLineH_West);
            }

            // Función para crear sendas peatonales (pasos de cebra)
            function createCrosswalks() {
                const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const stripeWidth = ROAD_WIDTH - 4; // Ancho de la franja a lo largo de la carretera
                
                // Usar las constantes definidas globalmente
                const stripeDepth = STRIPE_DEPTH; 
                const gapBetweenStripes = GAP_BETWEEN_STRIPES; 
                const numStripes = NUM_STRIPES; 
                const totalCrosswalkLength = NUM_STRIPES * STRIPE_DEPTH + (NUM_STRIPES - 1) * GAP_BETWEEN_STRIPES; 

                const stripeGeo = new THREE.PlaneGeometry(stripeWidth, stripeDepth);

                // Función auxiliar para crear un solo paso de cebra
                const addCrosswalk = (centerX, centerZ, rotationY) => {
                    const crosswalkGroup = new THREE.Group();
                    for (let i = 0; i < numStripes; i++) {
                        const stripe = new THREE.Mesh(stripeGeo, whiteMat);
                        stripe.position.y = 0.03; // Ligeramente por encima de la carretera
                        
                        // Calcula la posición relativa de cada franja dentro del grupo
                        // Las franjas se distribuyen simétricamente alrededor del centro del grupo
                        const stripeOffset = -(totalCrosswalkLength / 2) + (stripeDepth / 2) + i * (stripeDepth + gapBetweenStripes);
                        stripe.position.z = stripeOffset; // Alineación por defecto a lo largo del eje Z para el grupo sin rotar

                        crosswalkGroup.add(stripe);
                    }
                    crosswalkGroup.position.set(centerX, 0, centerZ);
                    crosswalkGroup.rotation.y = rotationY;
                    scene.add(crosswalkGroup);
                };

                const intersectionHalfWidth = ROAD_WIDTH / 2; // 11 unidades
                
                // Calcular el desplazamiento del centro del paso de cebra para que su borde más cercano esté en intersectionHalfWidth
                // Y se extienda hacia el centro de la intersección.
                const offsetFromIntersectionEdge = totalCrosswalkLength / 2;

                // Paso de Cebra Norte (tráfico de +Z a -Z)
                // Su borde más cercano estará en z = intersectionHalfWidth.
                // Su centro estará en z = intersectionHalfWidth - offsetFromIntersectionEdge.
                addCrosswalk(0, intersectionHalfWidth - offsetFromIntersectionEdge, 0); 
                
                // Paso de Cebra Sur (tráfico de -Z a +Z)
                // Su borde más cercano estará en z = -intersectionHalfWidth.
                // Su centro estará en z = -intersectionHalfWidth + offsetFromIntersectionEdge.
                addCrosswalk(0, -intersectionHalfWidth + offsetFromIntersectionEdge, 0);

                // Paso de Cebra Este (tráfico de +X a -X)
                // Su borde más cercano estará en x = intersectionHalfWidth.
                // Su centro estará en x = intersectionHalfWidth - offsetFromIntersectionEdge.
                addCrosswalk(intersectionHalfWidth - offsetFromIntersectionEdge, 0, Math.PI / 2);
                
                // Paso de Cebra Oeste (tráfico de -X a +X)
                // Su borde más cercano estará en x = -intersectionHalfWidth.
                // Su centro estará en x = -intersectionHalfWidth + offsetFromIntersectionEdge.
                addCrosswalk(-intersectionHalfWidth + offsetFromIntersectionEdge, 0, Math.PI / 2);
            }

            function createSensorVisuals() {
                const geo = new THREE.PlaneGeometry(ROAD_WIDTH-1, SENSOR_ZONE_LEN);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0x22d3ee, // Cyan
                    transparent: true, 
                    opacity: 0.15, 
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const sv = new THREE.Mesh(geo, mat);
                sv.rotation.x = -Math.PI/2;
                sv.position.set(0, 0.05, SENSOR_ZONE_POS); // Posición ajustada
                scene.add(sv);

                const sh = new THREE.Mesh(geo, mat);
                sh.rotation.x = -Math.PI/2;
                sh.rotation.z = -Math.PI/2;
                sh.position.set(SENSOR_ZONE_POS, 0.05, 0); // Posición ajustada
                scene.add(sh);

                // Objetos invisibles para trackear posición 2D
                const tV = new THREE.Object3D(); tV.name = 'targetV'; tV.position.set(0, 0, SENSOR_ZONE_POS); scene.add(tV); // Posición ajustada
                const tH = new THREE.Object3D(); tH.name = 'targetH'; tH.position.set(SENSOR_ZONE_POS, 0, 0); scene.add(tH); // Posición ajustada
            }

            function spawnCar() {
                const colors = [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316, 0x64748b];
                const col = colors[Math.floor(Math.random() * colors.length)];

                // Vertical: de +Z a -Z | Horizontal: de +X a -X
                const rand = Math.random();
                // Ajuste de probabilidad simple para balancear
                const street = rand > 0.5 ? Street.VERTICAL : Street.HORIZONTAL;
                const lane = Math.random() > 0.5 ? 0 : 1; 

                let x=0, z=0, rot=0;

                if (street === Street.VERTICAL) {
                    z = ROAD_LENGTH / 2 + 5 + (Math.random() - 0.5) * 5; // Añadida aleatoriedad
                    x = (lane === 0 ? LANE_WIDTH/2 : LANE_WIDTH*1.5);
                    rot = Math.PI; 
                } else {
                    x = ROAD_LENGTH / 2 + 5 + (Math.random() - 0.5) * 5; // Añadida aleatoriedad
                    z = (lane === 0 ? -LANE_WIDTH/2 : -LANE_WIDTH*1.5); 
                    rot = -Math.PI/2; 
                }

                // Check seguridad
                const safe = cars.every(c => {
                    if (c.street !== street || c.lane !== lane) return true;
                    const d = c.mesh.position.distanceTo(new THREE.Vector3(x,0,z));
                    return d > 35; // Espacio mínimo para spawnear
                });

                if (!safe) return;

                const grp = new THREE.Group();
                // Carrocería
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.4, CAR_LENGTH), new THREE.MeshStandardMaterial({ color: col }));
                body.position.y = 0.7;
                body.castShadow = true;
                
                // Techo
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                top.position.set(0, 1.75, -0.2);
                
                // Ruedas simuladas (bloques negros simples abajo)
                const wheels = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.5, 3.5), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                wheels.position.y = 0.25;

                grp.add(wheels, body, top);

                grp.position.set(x, 0, z);
                grp.rotation.y = rot;
                scene.add(grp);

                cars.push({
                    mesh: grp,
                    street: street,
                    lane: lane,
                    speed: 0,
                    maxSpeed: 35 + Math.random()*30, // Velocidad variada: de 35 a 65
                    accel: 15.0
                });
            }

            function updateCars(dt) {
                const limit = -(ROAD_LENGTH/2 + 20); // Límite de despawn
                
                for(let i = cars.length - 1; i >= 0; i--) {
                    const c = cars[i];
                    
                    // Despawn
                    if ((c.street === Street.VERTICAL && c.mesh.position.z < limit) ||
                        (c.street === Street.HORIZONTAL && c.mesh.position.x < limit)) {
                        scene.remove(c.mesh);
                        cars.splice(i, 1);
                        continue;
                    }

                    // Posición lineal
                    const pos = c.street === Street.VERTICAL ? c.mesh.position.z : c.mesh.position.x;
                    
                    // 1. Distancia al de adelante
                    let distAhead = 999;
                    cars.forEach(other => {
                        if (other === c) return;
                        if (other.street === c.street && other.lane === c.lane) {
                            const otherPos = c.street === Street.VERTICAL ? other.mesh.position.z : other.mesh.position.x;
                            // Ambos van hacia negativo. Si 'other' está en 80 y yo en 100, dist es 20.
                            const d = pos - otherPos;
                            if (d > 0 && d < distAhead) distAhead = d;
                        }
                    });

                    // 2. Distancia al semáforo
                    const stopLine = c.street === Street.VERTICAL ? STOP_LINE_V : STOP_LINE_H;
                    const distStop = pos - stopLine;
                    const light = c.street === Street.VERTICAL ? controller.stateV : controller.stateH;
                    const canGo = light === LightState.GREEN;

                    let targetSpeed = c.maxSpeed;

                    // Freno por coche (Prioridad seguridad)
                    if (distAhead < CAR_LENGTH + SAFETY_GAP) {
                        targetSpeed = 0;
                    } else if (distAhead < 30) {
                        targetSpeed = Math.min(targetSpeed, (distAhead - (CAR_LENGTH + SAFETY_GAP)) * 1.5);
                    }

                    // Freno por Semáforo
                    if (!canGo) {
                        // Si estamos acercándonos a la línea (distStop positivo) y dentro de rango (aumentado a 75)
                        if (distStop > 0 && distStop < 75) { 
                            if (distStop < 3) targetSpeed = 0;
                            else targetSpeed = Math.min(targetSpeed, distStop * 1.5);
                        }
                    }

                    // Física simple
                    if (c.speed < targetSpeed) c.speed += c.accel * dt;
                    else c.speed -= c.accel * 3 * dt; // Frenado fuerte

                    if (c.speed < 0) c.speed = 0;

                    const move = c.speed * dt;
                    if (c.street === Street.VERTICAL) c.mesh.position.z -= move;
                    else c.mesh.position.x -= move;
                }
            }

            function updateCounters() {
                // vMin ahora será STOP_LINE_V y vMax será STOP_LINE_V + SENSOR_ZONE_LEN
                const vMin = SENSOR_ZONE_POS - SENSOR_ZONE_LEN/2;
                const vMax = SENSOR_ZONE_POS + SENSOR_ZONE_LEN/2;
                
                let cV = 0, cH = 0;
                cars.forEach(c => {
                    if (c.street === Street.VERTICAL) {
                        if(c.mesh.position.z > vMin && c.mesh.position.z < vMax) cV++;
                    } else {
                        if(c.mesh.position.x > vMin && c.mesh.position.x < vMax) cH++;
                    }
                });

                elValV.innerText = cV;
                elValH.innerText = cH;

                return { cV, cH };
            }

            function updateUIProject() {
                const updatePos = (objName, el) => {
                    const obj = scene.getObjectByName(objName);
                    if(!obj) return;
                    
                    const v = new THREE.Vector3();
                    obj.getWorldPosition(v);
                    
                    // Ajuste visual para no tapar los coches
                    if (objName === 'targetV') v.x += 20; 
                    if (objName === 'targetH') v.z -= 20; 

                    v.project(camera);
                    
                    const x = (v.x * .5 + .5) * window.innerWidth;
                    const y = (v.y * -.5 + .5) * window.innerHeight;

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;
                };

                updatePos('targetV', elCounterV);
                updatePos('targetH', elCounterH);
            }

            let spawnTimer = 0;

            function animate() {
                requestAnimationFrame(animate);
                
                const dt = clock.getDelta() * SIMULATION_SPEED;
                
                // Spawn
                spawnTimer += dt;
                // Intervalo basado en densidad (100% = rapido, 1% = lento) con aleatoriedad
                const interval = (1.0 - (density / 100 * 0.95)) * (0.8 + Math.random() * 0.4); 
                if (spawnTimer > interval) {
                    spawnTimer = 0;
                    if(cars.length < 150) spawnCar(); // Aumentado el límite de autos a 150
                }

                updateCars(dt);
                const counts = updateCounters();
                controller.updateLogic(dt, counts.cV, counts.cH);
                controller.updateVisuals(); // Llamar updateVisuals en cada frame

                updateUIProject();
                renderer.render(scene, camera);
            }

            function onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Init
            init();
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>