<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación Tráfico WebGL - Vanilla JS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (Global CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/geometries/TextGeometry.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Contadores Flotantes (UI) */
        .sensor-counter {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #22d3ee; /* cyan-400 */
            border: 2px solid #06b6d4; /* cyan-500 */
            font-size: 1.8rem;
            font-weight: bold;
            padding: 0.5rem 1.0rem;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 60px;
        }
        .sensor-label {
            display: block;
            font-size: 0.6rem;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: -2px;
        }
        
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.95);
            border: 1px solid #374151;
            backdrop-filter: blur(4px);
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>

    <!-- UI: Contadores Flotantes -->
    <div id="counter-v" class="sensor-counter">
        <span id="valV">0</span>
        <span class="sensor-label" data-label-v>AV1</span>
    </div>
    <div id="counter-h" class="sensor-counter">
        <span id="valH">0</span>
        <span class="sensor-label" data-label-h>AV7</span>
    </div>

    <!-- UI: Controles -->
    <div class="absolute bottom-6 left-6 right-6 flex flex-col md:flex-row justify-between items-end gap-4 pointer-events-none z-20">
        
        <!-- Slider Densidad -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto w-full md:w-72">
            <label class="block text-sm font-bold mb-2 text-cyan-400 flex justify-between">
                <span>Densidad Tráfico</span>
                <span id="density-val">50%</span>
            </label>
            <input id="density-slider" type="range" min="1" max="100" value="50" 
                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
        </div>

        <!-- Botón Modo -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto flex items-center gap-4">
            <div>
                <p class="text-xs text-gray-400 mb-1 uppercase tracking-wider">Estado</p>
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></div>
                    <span id="status-text" class="font-bold text-sm">INTELIGENTE</span>
                </div>
            </div>
            <button id="mode-btn" 
                    class="px-4 py-2 rounded font-bold transition-all bg-cyan-600 hover:bg-cyan-500 text-white shadow text-sm border-b-2 border-cyan-800 active:border-b-0 active:translate-y-0.5">
                Cambiar Modo
            </button>
        </div>
    </div>

    <!-- Lógica Principal -->
    <script type="text/javascript">
        window.onload = function() {
            
            // --- CONFIGURACIÓN ---
            const ROAD_WIDTH = 22;
            const ROAD_LENGTH = 220; 
            const LANE_WIDTH = ROAD_WIDTH / 4; // 5.5
            const SIMULATION_SPEED = 0.3; // Velocidad de simulación
            
            // Dimensiones de las sendas peatonales
            const STRIPE_DEPTH = 1.0; 
            const GAP_BETWEEN_STRIPES = 0.5; 
            const NUM_STRIPES = 6; 
            const TOTAL_CROSSWALK_LENGTH = NUM_STRIPES * STRIPE_DEPTH + (NUM_STRIPES - 1) * GAP_BETWEEN_STRIPES; 

            // Líneas de detención
            const STOP_LINE_V = ROAD_WIDTH / 2 + 10; // 21
            const STOP_LINE_H = ROAD_WIDTH / 2 + 10; // 21

            // Zona Sensor
            const SENSOR_ZONE_LEN = 40; 
            const SENSOR_ZONE_POS = STOP_LINE_V + SENSOR_ZONE_LEN / 2; 

            const CAR_LENGTH = 4.5;
            const SAFETY_GAP = 4.0; 

            // Posiciones carriles
            const LANE_OUTER_OFFSET = ROAD_WIDTH / 2 - LANE_WIDTH / 2; 
            const LANE_INNER_OFFSET = ROAD_WIDTH / 2 - LANE_WIDTH * 1.5; 


            // Enumeraciones
            const Street = { VERTICAL: 'VERTICAL', HORIZONTAL: 'HORIZONTAL' };
            const LightState = { RED: 'RED', YELLOW: 'YELLOW', GREEN: 'GREEN' };
            const TurnIntent = { STRAIGHT: 'STRAIGHT', RIGHT: 'RIGHT', LEFT: 'LEFT' };


            // Variables Globales
            let scene, camera, renderer, clock;
            let cars = [];
            let density = 50;
            let isSmartMode = true;
            let controller;

            // Elementos DOM
            const elCounterV = document.getElementById('counter-v');
            const elCounterH = document.getElementById('counter-h');
            const elValV = document.getElementById('valV');
            const elValH = document.getElementById('valH');
            const elDensityVal = document.getElementById('density-val');
            const elStatusText = document.getElementById('status-text');
            const elStatusDot = document.getElementById('status-dot');
            
            // --- CLASE: Controlador de Semáforos ---
            class TrafficController {
                constructor(scene) {
                    this.stateV = LightState.GREEN; 
                    this.stateH = LightState.RED;   
                    this.timerV = 0;
                    this.timerH = 0;
                    this.cycleTimer = 0;
                    this.transitioning = false;
                    this.flashTimerV = 0;
                    this.flashTimerH = 0;

                    this.MIN_GREEN = 3.0; 
                    this.MAX_GREEN = 12.0;
                    this.YELLOW_TIME = 1.0; 
                    this.FIXED_TIME = 5.0; 

                    this.buildInfrastructure(scene); 
                    this.updateVisuals(0);           
                }

                buildInfrastructure(scene) {
                    const createBulb = () => new THREE.Mesh(
                        new THREE.SphereGeometry(2.0, 16, 16), 
                        new THREE.MeshBasicMaterial({ color: 0x111111 }) 
                    );

                    const createDetailedTrafficLight = (x, z, rotation) => {
                        const group = new THREE.Group();
                        
                        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.5 });
                        const poleHeight = 25; 
                        
                        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, poleHeight, 16), matBlack); 
                        pole.position.y = poleHeight / 2;
                        pole.castShadow = true;
                        group.add(pole);

                        const housingWidth = 5;
                        const housingHeight = 10;
                        const housingDepth = 3;

                        const housing = new THREE.Mesh(new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth), matBlack);
                        housing.position.set(0, poleHeight - 2 - (housingHeight / 2), 0.5); 
                        housing.castShadow = true;
                        group.add(housing);

                        const bulbZPos = housingDepth / 2 + 0.5; 
                        const mainLight = createBulb(); 
                        mainLight.position.set(0, 0, -bulbZPos); 
                        housing.add(mainLight);

                        const visorGeo = new THREE.BoxGeometry(housingWidth + 0.5, 0.5, 2.5); 
                        const visorMat = matBlack;
                        const visorZPos = housingDepth / 2 + 0.2; 
                        const visorYOffset = 2.5; 

                        const mainVisor = new THREE.Mesh(visorGeo, visorMat);
                        mainVisor.position.set(0, mainLight.position.y + visorYOffset, -visorZPos);
                        housing.add(mainVisor);
                        
                        group.position.set(x, 0, z);
                        group.rotation.y = rotation; 
                        scene.add(group);

                        return mainLight; 
                    };

                    this.lightsV = createDetailedTrafficLight(ROAD_WIDTH / 2 + 2, ROAD_WIDTH / 2 + 3, Math.PI); 
                    this.lightsH = createDetailedTrafficLight(ROAD_WIDTH / 2 + 3, -ROAD_WIDTH / 2 - 2, -Math.PI / 2);
                }

                setLightColor(mesh, state, flashTimer) {
                    let colorHex = 0x222222; 
                    const FLASH_RATE = 5; 

                    if (state === LightState.RED) colorHex = 0xff0000;
                    else if (state === LightState.GREEN) colorHex = 0x00ff00;
                    else if (state === LightState.YELLOW) {
                        if (Math.floor(flashTimer * FLASH_RATE) % 2 === 0) {
                            colorHex = 0xffaa00; 
                        } else {
                            colorHex = 0x222222; 
                        }
                    }
                    mesh.material.color.setHex(colorHex);
                }

                updateVisuals() {
                    this.setLightColor(this.lightsV, this.stateV, this.flashTimerV);
                    this.setLightColor(this.lightsH, this.stateH, this.flashTimerH);
                }

                switchLight(targetStreet) {
                    if (this.transitioning) return;
                    
                    if (targetStreet === Street.VERTICAL && this.stateV === LightState.GREEN) return;
                    if (targetStreet === Street.HORIZONTAL && this.stateH === LightState.GREEN) return;

                    this.transitioning = true;
                    
                    if (this.stateV === LightState.GREEN) {
                        this.stateV = LightState.YELLOW;
                        this.flashTimerV = 0; 
                    }
                    if (this.stateH === LightState.GREEN) {
                        this.stateH = LightState.YELLOW;
                        this.flashTimerH = 0; 
                    }
                    this.updateVisuals(); 

                    setTimeout(() => {
                        this.stateV = LightState.RED;
                        this.stateH = LightState.RED;
                        
                        if (targetStreet === Street.VERTICAL) this.stateV = LightState.GREEN;
                        else this.stateH = LightState.GREEN;
                        
                        this.timerV = 0;
                        this.timerH = 0;
                        this.transitioning = false;
                        this.updateVisuals(); 
                    }, this.YELLOW_TIME * 1000 / SIMULATION_SPEED);
                }

                updateLogic(dt, countV, countH) {
                    if (this.transitioning) return;

                    if (this.stateV === LightState.GREEN) this.timerV += dt;
                    if (this.stateH === LightState.GREEN) this.timerH += dt;

                    if (this.stateV === LightState.YELLOW) this.flashTimerV += dt;
                    if (this.stateH === LightState.YELLOW) this.flashTimerH += dt;

                    if (isSmartMode) {
                        if (this.stateV === LightState.GREEN && this.timerV > this.MAX_GREEN && countH > 0) {
                            this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MAX_GREEN && countV > 0) {
                            this.switchLight(Street.VERTICAL);
                        }
                        else if (this.stateV === LightState.GREEN && this.timerV > this.MIN_GREEN) {
                            if (countH > countV) this.switchLight(Street.HORIZONTAL);
                            else if (countH > 0 && countV === 0) this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MIN_GREEN) {
                            if (countV > countH) this.switchLight(Street.VERTICAL);
                            else if (countV > 0 && countH === 0) this.switchLight(Street.VERTICAL);
                        }
                        else if (countV === 0 && countH === 0) {
                             if (this.timerV > 20 || this.timerH > 20) {
                                 this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                             }
                        }
                    } else {
                        this.cycleTimer += dt;
                        if (this.cycleTimer > this.FIXED_TIME) {
                            this.cycleTimer = 0;
                            this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                        }
                    }
                }
            }

            // --- ESCENA PRINCIPAL ---
            function init() {
                const container = document.getElementById('canvas-container');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff); 

                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                camera.position.set(0, 100, 0); 
                camera.lookAt(0, 0, 0); 
                camera.rotation.z = Math.PI; 

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 80, 40);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -60;
                sun.shadow.camera.right = 60;
                sun.shadow.camera.top = 60;
                sun.shadow.camera.bottom = -60;
                scene.add(sun);

                createGround(); 
                createRoads(); 
                createAvenueZones();
                createCrosswalks(); 
                createSensorVisuals(); 
                createStreetLabels(); 
                updateUINames(); 

                controller = new TrafficController(scene); 

                window.addEventListener('resize', onResize);
                
                document.getElementById('density-slider').addEventListener('input', (e) => {
                    density = parseInt(e.target.value);
                    elDensityVal.innerText = density + '%';
                });

                document.getElementById('mode-btn').addEventListener('click', (e) => {
                    isSmartMode = !isSmartMode;
                    if(isSmartMode) {
                        elStatusText.innerText = "INTELIGENTE";
                        elStatusDot.classList.remove('bg-green-500');
                        elStatusDot.classList.add('bg-green-500');
                        elCounterV.style.display = 'block';
                        elCounterH.style.display = 'block';
                    } else {
                        elStatusText.innerText = "MANUAL (Cíclico)";
                        elStatusDot.classList.remove('bg-green-500');
                        elStatusDot.classList.add('bg-orange-500');
                        elCounterV.style.display = 'none';
                        elCounterH.style.display = 'none';
                    }
                });

                clock = new THREE.Clock();
                animate();
                
                elCounterV.style.display = 'block';
                elCounterH.style.display = 'block';
            }

            function createGround() {
                const groundGeo = new THREE.PlaneGeometry(2000, 2000);
                const groundMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.05; 
                ground.receiveShadow = true; 
                scene.add(ground);

                const roadMat = new THREE.MeshBasicMaterial({ color: 0x696969 });
                const roadV = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, 2000), roadMat);
                roadV.rotation.x = -Math.PI / 2;
                roadV.receiveShadow = true;
                scene.add(roadV);

                const roadH = new THREE.Mesh(new THREE.PlaneGeometry(2000, ROAD_WIDTH), roadMat);
                roadH.rotation.x = -Math.PI / 2;
                roadH.receiveShadow = true;
                scene.add(roadH);

                // Líneas de frenado (Solo en carriles de entrada, ancho ROAD_WIDTH/2)
                const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

                // Vertical: Ancho 11 (X), Alto 1.2 (Z)
                const stopLineGeoV = new THREE.PlaneGeometry(ROAD_WIDTH / 2, 1.2);
                const stopV = new THREE.Mesh(stopLineGeoV, stopLineMat);
                stopV.rotation.x = -Math.PI / 2;
                // X positivo (derecha), Z positivo (antes de intersección desde Norte)
                stopV.position.set(ROAD_WIDTH / 4, 0.05, STOP_LINE_V);
                scene.add(stopV);

                // Horizontal: Ancho 1.2 (X), Alto 11 (Z)
                const stopLineGeoH = new THREE.PlaneGeometry(1.2, ROAD_WIDTH / 2);
                const stopH = new THREE.Mesh(stopLineGeoH, stopLineMat);
                stopH.rotation.x = -Math.PI / 2;
                // X positivo (antes de intersección desde Este), Z negativo (carril inferior)
                stopH.position.set(STOP_LINE_H, 0.05, -ROAD_WIDTH / 4);
                scene.add(stopH);
            }

            function createRoads() {
                const roadMat = new THREE.MeshBasicMaterial({ color: 0x696969 }); 

                const inter = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_WIDTH), roadMat);
                inter.rotation.x = -Math.PI / 2;
                inter.position.y = 0.01;
                inter.receiveShadow = true;
                scene.add(inter);

                const yellow = new THREE.MeshBasicMaterial({ color: 0xfacc15 });
                const white = new THREE.MeshBasicMaterial({ color: 0xffffff });

                const lineThickness = 0.5; 

                // Líneas Amarillas Centrales
                const yellowSegmentLength = (ROAD_LENGTH / 2) - (ROAD_WIDTH / 2); 
                const yellowMidpointOffset = (ROAD_LENGTH / 2 + ROAD_WIDTH / 2) / 2; 

                const yellowLineV_North = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, yellowSegmentLength), yellow);
                yellowLineV_North.rotation.x = -Math.PI / 2;
                yellowLineV_North.position.set(0, 0.02, yellowMidpointOffset);
                scene.add(yellowLineV_North);

                const yellowLineV_South = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, yellowSegmentLength), yellow);
                yellowLineV_South.rotation.x = -Math.PI / 2;
                yellowLineV_South.position.set(0, 0.02, -yellowMidpointOffset);
                scene.add(yellowLineV_South);

                const yellowLineH_East = new THREE.Mesh(new THREE.PlaneGeometry(yellowSegmentLength, lineThickness), yellow);
                yellowLineH_East.rotation.x = -Math.PI / 2;
                yellowLineH_East.position.set(yellowMidpointOffset, 0.02, 0);
                scene.add(yellowLineH_East);

                const yellowLineH_West = new THREE.Mesh(new THREE.PlaneGeometry(yellowSegmentLength, lineThickness), yellow);
                yellowLineH_West.rotation.x = -Math.PI / 2;
                yellowLineH_West.position.set(-yellowMidpointOffset, 0.02, 0);
                scene.add(yellowLineH_West);

                // Líneas Blancas Exteriores
                const edgeLineSegmentLength = yellowSegmentLength; 
                const edgeLineMidpointOffset = yellowMidpointOffset; 

                const whiteEdgeLineV_EastNorth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_EastNorth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_EastNorth.position.set(ROAD_WIDTH / 2, 0.02, edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_EastNorth);

                const whiteEdgeLineV_WestNorth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_WestNorth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_WestNorth.position.set(-ROAD_WIDTH / 2, 0.02, edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_WestNorth);

                const whiteEdgeLineV_EastSouth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_EastSouth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_EastSouth.position.set(ROAD_WIDTH / 2, 0.02, -edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_EastSouth);

                const whiteEdgeLineV_WestSouth = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, edgeLineSegmentLength), white);
                whiteEdgeLineV_WestSouth.rotation.x = -Math.PI / 2;
                whiteEdgeLineV_WestSouth.position.set(-ROAD_WIDTH / 2, 0.02, -edgeLineMidpointOffset);
                scene.add(whiteEdgeLineV_WestSouth);


                const whiteEdgeLineH_NorthEast = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_NorthEast.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_NorthEast.position.set(edgeLineMidpointOffset, 0.02, ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_NorthEast);

                const whiteEdgeLineH_SouthEast = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_SouthEast.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_SouthEast.position.set(edgeLineMidpointOffset, 0.02, -ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_SouthEast);

                const whiteEdgeLineH_NorthWest = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_NorthWest.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_NorthWest.position.set(-edgeLineMidpointOffset, 0.02, ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_NorthWest);

                const whiteEdgeLineH_SouthWest = new THREE.Mesh(new THREE.PlaneGeometry(edgeLineSegmentLength, lineThickness), white);
                whiteEdgeLineH_SouthWest.rotation.x = -Math.PI / 2;
                whiteEdgeLineH_SouthWest.position.set(-edgeLineMidpointOffset, 0.02, -ROAD_WIDTH / 2);
                scene.add(whiteEdgeLineH_SouthWest);
            }
            
            function createAvenueZones() {
                const mat = new THREE.LineDashedMaterial({
                    color: 0x555555, // Dark grey
                    linewidth: 1,
                    scale: 1,
                    dashSize: 2,
                    gapSize: 2,
                });

                const segmentLength = (ROAD_LENGTH / 2) - (ROAD_WIDTH / 2);
                const segmentWidth = ROAD_WIDTH / 2;
                const centerOffset = (ROAD_LENGTH / 2 + ROAD_WIDTH / 2) / 2;
                
                const createZone = (x, z, width, height) => {
                    const shape = new THREE.Shape();
                    shape.moveTo(-width/2, -height/2);
                    shape.lineTo(width/2, -height/2);
                    shape.lineTo(width/2, height/2);
                    shape.lineTo(-width/2, height/2);
                    shape.closePath();

                    const points = shape.getPoints();
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const line = new THREE.Line(geometry, mat);
                    line.computeLineDistances();
                    
                    line.position.set(x, 0.06, z); // Slightly above the road lines
                    line.rotation.x = -Math.PI / 2;
                    scene.add(line);
                };

                // Vertical Avenues
                createZone(segmentWidth / 2, centerOffset, segmentWidth, segmentLength); // AV1
                createZone(-segmentWidth / 2, centerOffset, segmentWidth, segmentLength); // AV2
                createZone(segmentWidth / 2, -centerOffset, segmentWidth, segmentLength); // AV6
                createZone(-segmentWidth / 2, -centerOffset, segmentWidth, segmentLength); // AV5
                
                // Horizontal Avenues
                createZone(centerOffset, segmentWidth / 2, segmentLength, segmentWidth); // AV8
                createZone(centerOffset, -segmentWidth / 2, segmentLength, segmentWidth); // AV7
                createZone(-centerOffset, segmentWidth / 2, segmentLength, segmentWidth); // AV3
                createZone(-centerOffset, -segmentWidth / 2, segmentLength, segmentWidth); // AV4
            }

            function createCrosswalks() {
                const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const stripeWidth = ROAD_WIDTH - 4; 
                
                const stripeDepth = STRIPE_DEPTH; 
                const gapBetweenStripes = GAP_BETWEEN_STRIPES; 
                const numStripes = NUM_STRIPES; 
                const totalCrosswalkLength = NUM_STRIPES * STRIPE_DEPTH + (NUM_STRIPES - 1) * GAP_BETWEEN_STRIPES; 

                const stripeGeo = new THREE.PlaneGeometry(stripeWidth, stripeDepth);

                const addCrosswalk = (centerX, centerZ, rotationY) => {
                    const crosswalkGroup = new THREE.Group();
                    for (let i = 0; i < numStripes; i++) {
                        const stripe = new THREE.Mesh(stripeGeo, whiteMat);
                        stripe.position.y = 0.03; 
                        
                        const stripeOffset = -(totalCrosswalkLength / 2) + (stripeDepth / 2) + i * (stripeDepth + gapBetweenStripes);
                        stripe.position.z = stripeOffset; 

                        crosswalkGroup.add(stripe);
                    }
                    crosswalkGroup.position.set(centerX, 0, centerZ);
                    crosswalkGroup.rotation.y = rotationY;
                    scene.add(crosswalkGroup);
                };

                const intersectionHalfWidth = ROAD_WIDTH / 2; 
                
                const offsetFromIntersectionEdge = totalCrosswalkLength / 2;

                addCrosswalk(0, intersectionHalfWidth - offsetFromIntersectionEdge, 0); 
                addCrosswalk(0, -intersectionHalfWidth + offsetFromIntersectionEdge, 0);
                addCrosswalk(intersectionHalfWidth - offsetFromIntersectionEdge, 0, Math.PI / 2);
                addCrosswalk(-intersectionHalfWidth + offsetFromIntersectionEdge, 0, Math.PI / 2);
            }

            // Visualización de Zona (Carril Izquierdo, de línea amarilla a exterior)
            function createSensorVisuals() {
                scene.children.filter(child => child.isSensorMesh || child.name === 'targetV' || child.name === 'targetH' || child.name === 'sensorN' || child.name === 'sensorO').forEach(child => scene.remove(child));

                const mat = new THREE.MeshBasicMaterial({ color: 0x22d3ee, transparent: true, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false }); 

                // Zona Norte (Vertical)
                const geoV = new THREE.PlaneGeometry(ROAD_WIDTH / 2, SENSOR_ZONE_LEN);
                const sv = new THREE.Mesh(geoV, mat);
                sv.isSensorMesh = true; 
                sv.name = 'sensorN'; 
                sv.rotation.x = -Math.PI/2;
                sv.position.set(ROAD_WIDTH / 4, 0.05, SENSOR_ZONE_POS);
                scene.add(sv);

                // Zona Oeste (Horizontal) 
                const geoH = new THREE.PlaneGeometry(SENSOR_ZONE_LEN, ROAD_WIDTH / 2);
                const sh = new THREE.Mesh(geoH, mat);
                sh.isSensorMesh = true;
                sh.name = 'sensorO'; 
                sh.rotation.x = -Math.PI/2;
                sh.position.set(SENSOR_ZONE_POS, 0.05, -ROAD_WIDTH / 4);
                scene.add(sh);

                const tV = new THREE.Object3D(); tV.name = 'targetV'; tV.position.set(ROAD_WIDTH / 4, 0, SENSOR_ZONE_POS); scene.add(tV);
                const tH = new THREE.Object3D(); tH.name = 'targetH'; tH.position.set(SENSOR_ZONE_POS, 0, -ROAD_WIDTH / 4); scene.add(tH);
            }

            function createStreetLabels() {
                const loader = new THREE.FontLoader();
                loader.load('https://raw.githack.com/mrdoob/three.js/master/examples/fonts/helvetiker_bold.typeface.json', font => {
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Texto NEGRO puro
                    const labels = [
                        // ARRIBA (Screen Top / World +Z due to 180 camera rot)
                        // AV1 (Left/+X), AV2 (Right/-X)
                        { t: 'AV1', p: [5.5, 0.1, 16], r: Math.PI },
                        { t: 'AV2', p: [-5.5, 0.1, 16], r: Math.PI },

                        // ABAJO (Screen Bottom / World -Z)
                        // AV6 (Left/+X), AV5 (Right/-X)
                        { t: 'AV6', p: [6, 0.1, -16], r: Math.PI },
                        { t: 'AV5', p: [-6, 0.1, -16], r: Math.PI },

                        // IZQUIERDA (Screen Left / World +X)
                        // AV8 (Top/+Z), AV7 (Bottom/-Z)
                        { t: 'AV8', p: [20, 0.1, 6], r: Math.PI },
                        { t: 'AV7', p: [20, 0.1, -6], r: Math.PI },

                        // DERECHA (Screen Right / World -X)
                        // AV3 (Top/+Z), AV4 (Bottom/-Z)
                        { t: 'AV3', p: [-14, 0.1, 6], r: Math.PI },
                        { t: 'AV4', p: [-14, 0.1, -6], r: Math.PI }
                    ];
                    labels.forEach(l => {
                        const geo = new THREE.TextGeometry(l.t, { font: font, size: 2.5, height: 0.1, bevelEnabled: false });
                        geo.center();
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.rotation.z = l.r; 
                        mesh.position.set(l.p[0], l.p[1], l.p[2]);
                        scene.add(mesh);
                    });
                });
            }

            function updateUINames() {
                const labelV = document.querySelector('[data-label-v]'); 
                const labelH = document.querySelector('[data-label-h]'); 
                if(labelV) labelV.innerText = 'AV1';
                if(labelH) labelH.innerText = 'AV7';
            }


            function spawnCar() {
                const colors = [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316, 0x64748b];
                const col = colors[Math.floor(Math.random() * colors.length)];

                const rand = Math.random();
                const street = rand > 0.5 ? Street.VERTICAL : Street.HORIZONTAL;
                
                let lane;
                let turnIntent;
                let x=0, z=0, rot=0;

                if (street === Street.VERTICAL) {
                    z = ROAD_LENGTH / 2 + 5 + (Math.random() - 0.5) * 5;
                    rot = 0;
                    if (Math.random() < 0.3) { // 30% de probabilidad de girar a la derecha
                        turnIntent = TurnIntent.RIGHT;
                        lane = 0; // Debe estar en el carril exterior (derecho) para girar a la derecha
                    } else {
                        turnIntent = TurnIntent.STRAIGHT;
                        lane = Math.random() > 0.5 ? 0 : 1; // Puede estar en cualquier carril para ir recto
                    }
                    x = (lane === 0 ? LANE_OUTER_OFFSET : LANE_INNER_OFFSET);
                } else { // HORIZONTAL
                    x = ROAD_LENGTH / 2 + 5 + (Math.random() - 0.5) * 5;
                    if (Math.random() < 0.3) {
                        turnIntent = TurnIntent.RIGHT;
                        lane = 0;
                    } else {
                        turnIntent = TurnIntent.STRAIGHT;
                        lane = Math.random() > 0.5 ? 0 : 1;
                    }
                    z = (lane === 0 ? -LANE_OUTER_OFFSET : -LANE_INNER_OFFSET);
                    rot = Math.PI / 2;
                }

                const safe = cars.every(c => {
                    if (c.street !== street || c.lane !== lane) return true;
                    const d = c.mesh.position.distanceTo(new THREE.Vector3(x,0,z));
                    return d > 35; 
                });

                if (!safe) return;

                const grp = new THREE.Group();
                
                // --- Visualización de Burbuja de Colisión ---
                const bubbleGeometry = new THREE.CircleGeometry(1, 32); // Radio 1, se escalará dinámicamente
                const bubbleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0077ff, // Azul
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    depthWrite: false // Evita problemas de renderizado con otras transparencias
                });
                const bubbleMesh = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleMesh.rotation.x = -Math.PI / 2; // Plana sobre el suelo
                bubbleMesh.position.y = 0.1; // Ligeramente por encima del asfalto
                grp.add(bubbleMesh);
                // --- Fin de Visualización ---

                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.4, CAR_LENGTH), new THREE.MeshStandardMaterial({ color: col }));
                body.position.y = 0.7;
                body.castShadow = true;
                
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                top.position.set(0, 1.75, -0.2);
                
                const wheels = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.5, 3.5), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                wheels.position.y = 0.25;

                // Indicador Derecho (Verde)
                const rightIndicatorMat = new THREE.MeshBasicMaterial({ color: 0x22c55e });
                const indicatorGeo = new THREE.BoxGeometry(0.2, 0.4, 0.8);
                const rightIndicator = new THREE.Mesh(indicatorGeo, rightIndicatorMat);
                rightIndicator.position.set(1.15, body.position.y, 0); 
                grp.add(rightIndicator);

                // Indicador Izquierdo (Rojo)
                const leftIndicatorMat = new THREE.MeshBasicMaterial({ color: 0xef4444 });
                const leftIndicator = new THREE.Mesh(indicatorGeo, leftIndicatorMat);
                leftIndicator.position.set(-1.15, body.position.y, 0);
                grp.add(leftIndicator);

                grp.add(wheels, body, top);

                grp.position.set(x, 0, z);
                grp.rotation.y = rot;
                scene.add(grp);

                const car = {
                    mesh: grp,
                    street: street,
                    lane: lane,
                    speed: 0, 
                    maxSpeed: 35 + Math.random()*30, 
                    accel: 15.0,
                    turnIntent: turnIntent, 
                    isTurning: false,        
                    turnProgress: 0,         
                    targetStreet: null,      
                    rotatedAngle: 0,
                    isEntryTraffic: true,
                    isUnrestricted: false,
                    bubbleMesh: bubbleMesh // Referencia a la malla de la burbuja
                };
                car.speed = car.maxSpeed; 
                cars.push(car);
            }

            function updateCars(dt) {
                for(let i = cars.length - 1; i >= 0; i--) {
                    const c = cars[i];
                    
                    const distanceFromCenter = Math.sqrt(c.mesh.position.x**2 + c.mesh.position.z**2);
                    if (distanceFromCenter > ROAD_LENGTH / 2 + 50) {
                        scene.remove(c.mesh);
                        cars.splice(i, 1);
                        continue;
                    }

                    // Unrestricted state for escape routes (AV8)
                    if (c.street === Street.HORIZONTAL && c.mesh.position.x > (ROAD_WIDTH / 2) && c.mesh.position.z > 0) {
                        c.isUnrestricted = true;
                    }

                    if (c.isEntryTraffic) {
                        if ((c.street === Street.VERTICAL && c.mesh.position.z < 0) ||
                            (c.street === Street.HORIZONTAL && c.mesh.position.x < 0)) {
                            c.isEntryTraffic = false;
                        }
                    }

                    const INTERSECTION_HALF_WIDTH = ROAD_WIDTH / 2;

                    // 1. DETECCIÓN DE GIRO
                    if (!c.isTurning && (c.turnIntent === TurnIntent.RIGHT || (c.turnIntent === TurnIntent.LEFT && c.street === Street.VERTICAL))) {
                        const inZone = (c.street === Street.VERTICAL && c.mesh.position.z < INTERSECTION_HALF_WIDTH && c.mesh.position.z > -INTERSECTION_HALF_WIDTH) ||
                                       (c.street === Street.HORIZONTAL && c.mesh.position.x < INTERSECTION_HALF_WIDTH && c.mesh.position.x > -INTERSECTION_HALF_WIDTH);
                        if (inZone) {
                             c.isTurning = true;
                        }
                    }
                    
                    // --- Actualizar Burbuja de Colisión ---
                    const brakingStartGap = (c.isUnrestricted || c.isTurning) ? 12.0 : 25.0;
                    const bubbleRadius = brakingStartGap / 4;

                    let scaleX = bubbleRadius; // Escala que afecta al ancho
                    let scaleY = bubbleRadius; // Escala que afecta al largo (dirección de marcha)

                    if (!c.isTurning) {
                        const maxRadius = LANE_WIDTH / 2; // Radio máximo para permanecer en el carril
                        scaleX = Math.min(bubbleRadius, maxRadius);
                    }
                    
                    c.bubbleMesh.scale.set(scaleX, scaleY, 1);
                    // --- Fin Actualización ---

                    const stopLine = c.street === Street.VERTICAL ? STOP_LINE_V : STOP_LINE_H;
                    const pos = c.street === Street.VERTICAL ? c.mesh.position.z : c.mesh.position.x;
                    const distStop = pos - stopLine;

                    // 2. CÁLCULO DE VELOCIDAD OBJETIVO
                    let targetSpeed = c.maxSpeed;
                    
                    // A. SEMÁFORO (Todos los autos deben respetar el semáforo)
                    if (c.isEntryTraffic && !c.isTurning && distStop > 0 && !c.isUnrestricted) {
                        const light = c.street === Street.VERTICAL ? controller.stateV : controller.stateH;
                        if (light === LightState.RED || light === LightState.YELLOW) {
                            if (distStop < 2.5) {
                                targetSpeed = 0;
                            } else {
                                targetSpeed = Math.min(targetSpeed, (distStop - 1.5) * 3.0);
                            }
                        }
                    }

                    // 3. LÓGICA ANTI-COLISIÓN (Prioridad Máxima)
                    if (!c.isTurning) {
                        let minGap = Infinity;
                        let frontCarSpeed = 0;

                        for (let j = 0; j < cars.length; j++) {
                            const other = cars[j];
                            if (c === other) continue;

                            let gap = Infinity;
                            let isRelevant = false;

                            // --- Lógica de seguimiento en el mismo carril/calle (para todos los autos) ---
                            if (c.street === other.street) {
                                // Reemplaza la comprobación de carril por una de proximidad en el eje transversal,
                                // ya que los autos que giran pierden su designación de carril.
                                let samePath = false;
                                if (c.street === Street.VERTICAL) {
                                    if (Math.abs(c.mesh.position.x - other.mesh.position.x) < LANE_WIDTH * 0.5) samePath = true;
                                } else { // HORIZONTAL
                                    if (Math.abs(c.mesh.position.z - other.mesh.position.z) < LANE_WIDTH * 0.5) samePath = true;
                                }

                                if(samePath) {
                                    const otherPos = other.street === Street.VERTICAL ? other.mesh.position.z : other.mesh.position.x;
                                    gap = pos - otherPos; 
                                    // Un gap positivo significa que 'other' está detrás de 'c' en la dirección del viaje
                                    if (gap > 0) isRelevant = true;
                                }
                            }
                            
                            // --- Comprobación de peligro en intersección (SOLO para tráfico de entrada) ---
                            if (c.isEntryTraffic && other.isTurning) {
                                const d = c.mesh.position.distanceTo(other.mesh.position);
                                if (d < 14.0) { // Comprobar proximidad
                                    // Si esta es una amenaza más cercana que un auto en el mismo carril, priorizarla.
                                    if (d < gap) { 
                                        gap = d;
                                        isRelevant = true;
                                    }
                                }
                            }

                            if (isRelevant && gap < minGap) {
                                minGap = gap;
                                frontCarSpeed = other.speed;
                            }
                        }

                        const minSafeGap = c.isUnrestricted ? 3.0 : 6.5; 
                        
                        if (minGap < brakingStartGap) {
                            if (minGap < minSafeGap) {
                                targetSpeed = 0; 
                            } else {
                                const safetyFactor = (minGap - minSafeGap) / (brakingStartGap - minSafeGap);
                                const desiredSpeed = Math.min(c.maxSpeed, frontCarSpeed);
                                targetSpeed = Math.min(targetSpeed, desiredSpeed * safetyFactor + (minGap - minSafeGap) * 2.0);
                            }
                        }
                    }

                    // 4. APLICACIÓN DE MOVIMIENTO
                    const lerpFactor = targetSpeed < c.speed ? 0.3 : 0.1;
                    c.speed += (targetSpeed - c.speed) * lerpFactor;
                    
                    if (c.speed < 0.1 && targetSpeed === 0) c.speed = 0;

                    const move = c.speed * dt;

                    // Ejecutar Giro Físico
                    if (c.isTurning) {
                        if (c.turnIntent === TurnIntent.RIGHT) {
                            const turnRadius = LANE_OUTER_OFFSET;
                            const deltaYaw = (move / turnRadius);
                            
                            if (c.rotatedAngle < Math.PI / 2) {
                                c.mesh.rotation.y -= deltaYaw;
                                c.rotatedAngle += deltaYaw;
                            } else {
                                c.isTurning = false;
                                c.turnIntent = TurnIntent.STRAIGHT;
                                if (c.street === Street.VERTICAL) {
                                    c.mesh.rotation.y = -Math.PI / 2;
                                    c.street = Street.HORIZONTAL;
                                } else {
                                    c.mesh.rotation.y = 0;
                                    c.street = Street.VERTICAL;
                                }
                                c.rotatedAngle = 0;
                                c.isEntryTraffic = false; 
                                c.isUnrestricted = true;
                            }
                        } else if (c.turnIntent === TurnIntent.LEFT && c.street === Street.VERTICAL) {
                            // This code is now unreachable due to spawnCar changes, but kept for safety.
                            const turnRadius = LANE_OUTER_OFFSET + LANE_WIDTH / 2;
                            const deltaYaw = (move / turnRadius);

                            if (c.rotatedAngle < Math.PI / 2) {
                                c.mesh.rotation.y += deltaYaw; // Counter-clockwise for left turn
                                c.rotatedAngle += deltaYaw;
                            } else {
                                c.isTurning = false;
                                c.turnIntent = TurnIntent.STRAIGHT;
                                c.mesh.rotation.y = Math.PI / 2; // Face left
                                c.street = Street.HORIZONTAL;
                                c.rotatedAngle = 0;
                                c.isEntryTraffic = false;
                                c.isUnrestricted = true;
                            }
                        }
                    }

                    const currentRotationY = c.mesh.rotation.y;
                    c.mesh.position.x += -Math.sin(currentRotationY) * move;
                    c.mesh.position.z += -Math.cos(currentRotationY) * move;
                }
            }


            function updateCounters() {
                let cV = 0, cH = 0;
                cars.forEach(c => {
                    const posX = c.mesh.position.x;
                    const posZ = c.mesh.position.z;

                    // Sensor Vertical (AV1): carril derecho de la vía vertical (X > 0)
                    if (c.street === Street.VERTICAL && 
                        posX > 0 && posX <= ROAD_WIDTH / 2 && 
                        posZ >= STOP_LINE_V && posZ <= STOP_LINE_V + SENSOR_ZONE_LEN) {
                        cV++;
                    }
                    
                    // Sensor Horizontal (AV7): carril inferior de la vía horizontal (Z < 0)
                    if (c.street === Street.HORIZONTAL && 
                        posZ < 0 && posZ >= -ROAD_WIDTH / 2 && 
                        posX >= STOP_LINE_H && posX <= STOP_LINE_H + SENSOR_ZONE_LEN) {
                        cH++;
                    }
                });
                document.getElementById('valV').innerText = cV;
                document.getElementById('valH').innerText = cH;
                return { cV, cH };
            }

            function updateUIProject() {
                const updatePos = (objName, el) => {
                    const obj = scene.getObjectByName(objName);
                    if(!obj) return;
                    
                    const v = new THREE.Vector3();
                    obj.getWorldPosition(v);
                    
                    if (objName === 'targetV') v.x += 10; 
                    if (objName === 'targetH') v.z -= 10; 

                    v.project(camera);
                    
                    const x = (v.x * .5 + .5) * window.innerWidth;
                    const y = (v.y * -.5 + .5) * window.innerHeight;

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;
                };

                updatePos('targetV', elCounterV);
                updatePos('targetH', elCounterH);
            }

            let spawnTimer = 0;

            function animate() {
                requestAnimationFrame(animate);
                
                const dt = clock.getDelta() * SIMULATION_SPEED;
                
                spawnTimer += dt;
                const interval = (1.0 - (density / 100 * 0.95)) * (0.8 + Math.random() * 0.4); 
                if (spawnTimer > interval) {
                    spawnTimer = 0;
                    if(cars.length < 150) spawnCar(); 
                }

                updateCars(dt);
                const counts = updateCounters();
                controller.counts = counts; 
                controller.updateLogic(dt, counts.cV, counts.cH);
                controller.updateVisuals(); 

                updateUIProject();
                renderer.render(scene, camera);
            }

            function onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            init();
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>