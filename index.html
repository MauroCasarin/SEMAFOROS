<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación Tráfico WebGL - Vanilla JS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (Modern ES6 Import) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.140.0/build/three.module.js",
            "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.140.0/examples/jsm/loaders/FontLoader.js",
            "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.140.0/examples/jsm/geometries/TextGeometry.js"
        }
    }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.7);
            border: 1px solid #374151;
            backdrop-filter: blur(4px);
        }

        /* Contadores Flotantes (UI) - Responsivos */
        .sensor-counter {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #22d3ee; /* cyan-400 */
            border: 1px solid #06b6d4; /* cyan-500 */
            font-weight: bold;
            border-radius: 0.375rem;
            /* pointer-events: none; */ /* Se habilita para hover */
            z-index: 10;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            text-align: center;
            transition: all 0.2s ease-in-out;
            cursor: help;
            
            /* Talla para móviles */
            font-size: 0.5rem;
            padding: 0.05rem 0.2rem;
            min-width: 20px;
        }
        .sensor-label {
            display: block;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: -2px;
             /* Talla para móviles */
            font-size: 0.3rem;
        }

        /* Tallas para pantallas más grandes */
        @media (min-width: 768px) {
            .sensor-counter {
                font-size: 0.7rem;
                padding: 0.1rem 0.35rem;
                min-width: 26px;
            }
            .sensor-label {
                font-size: 0.4rem;
            }
        }

        /* Estilos para el panel minimizable */
        #collapsible-controls {
            max-height: 500px; /* Suficientemente grande para el contenido */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 1;
        }

        #collapsible-controls.collapsed {
            max-height: 0;
            margin-top: 0 !important;
            opacity: 0;
        }

        #control-panel-wrapper.minimized {
            min-height: auto;
            width: auto !important;
            min-width: 0 !important;
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>
    
    <!-- UI: Barra de Título Superior -->
    <div class="absolute top-0 left-0 right-0 p-2 z-20 pointer-events-none">
        <div class="ui-panel max-w-xs mx-auto rounded-lg shadow-xl text-white pointer-events-auto text-center py-0.5 px-3">
            <div class="flex items-center justify-center gap-2">
                 <h1 class="text-base font-bold text-cyan-400">Semáforos Inteligentes</h1>
                 <a href="https://www.instagram.com/3d_mc_3d/reels/?next=%2F" target="_blank" rel="noopener noreferrer" class="pointer-events-auto">
                    <img src="https://raw.githubusercontent.com/MauroCasarin/SEMAFOROS/refs/heads/main/Logo%20MC.png" alt="MC Logo" class="h-5 w-5 transition-transform hover:scale-110">
                 </a>
            </div>
        </div>
    </div>


    <!-- UI: Contadores Flotantes -->
    <div id="counter-a1" class="sensor-counter">
        <span id="valA1">0</span>
        <span class="sensor-label" data-label-a1>A1</span>
    </div>
    <div id="counter-a7" class="sensor-counter">
        <span id="valA7">0</span>
        <span class="sensor-label" data-label-a7>A7</span>
    </div>
    <div id="counter-a3" class="sensor-counter">
        <span id="valA3">0</span>
        <span class="sensor-label" data-label-a3>A3</span>
    </div>
    <div id="counter-a5" class="sensor-counter">
        <span id="valA5">0</span>
        <span class="sensor-label" data-label-a5>A5</span>
    </div>

    <!-- UI: Panel de Control Inferior Unificado -->
    <div id="control-panel-wrapper" class="absolute z-20 pointer-events-auto transition-all duration-400" style="bottom: 1rem; left: 1rem; width: clamp(320px, 90vw, 448px); min-width: 280px; cursor: default;">
        <div class="ui-panel p-2 md:p-3 rounded-xl shadow-2xl text-white flex flex-col items-center w-full relative">
            
            <!-- Botón para Minimizar/Maximizar -->
            <button id="toggle-panel-btn" class="absolute top-1 right-1 p-1 rounded-full hover:bg-gray-600 focus:outline-none z-10">
                <svg id="toggle-icon" class="w-4 h-4 text-gray-400 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
            </button>
            
            <!-- Estadísticas de Vehículos (Siempre Visibles) -->
            <div class="w-full text-xs px-1 grid grid-cols-2 gap-x-4">
                <div class="flex items-center gap-2 text-gray-400">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 6l12-3"></path></svg>
                    <span>TOTAL:</span>
                    <span id="total-vehicles-count" class="font-bold text-white text-base">0</span>
                </div>
                <div class="flex items-center gap-2 text-gray-400">
                     <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                    <span>FLUIDEZ:</span>
                    <span id="fluidity-index-value" class="font-bold text-green-400 text-base">100%</span>
                </div>
                <div class="flex items-center gap-2 text-gray-400 mt-1">
                     <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span>DETENIDOS:</span>
                    <span id="stopped-vehicles-count" class="font-bold text-white text-base">0</span>
                </div>
            </div>

            <!-- Contenedor Colapsable -->
            <div id="collapsible-controls" class="w-full">
                <div class="pt-2 mt-2 border-t border-gray-700 flex flex-col md:flex-row items-stretch gap-3 w-full">
                    
                    <!-- Card: Controles de Densidad -->
                    <div class="w-full md:flex-1 bg-gray-900/50 p-2 rounded-lg">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2 text-center">Densidad</h3>
                        <div class="space-y-2">
                            <div>
                                <label class="block text-xs font-bold mb-1 text-cyan-400 flex justify-between">
                                    <span>Norte-Sur</span>
                                    <span id="density-val-ns">50%</span>
                                </label>
                                <input id="density-slider-ns" type="range" min="1" max="100" value="50" 
                                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
                            </div>
                            <div>
                                <label class="block text-xs font-bold mb-1 text-cyan-400 flex justify-between">
                                    <span>Este-Oeste</span>
                                    <span id="density-val-ew">50%</span>
                                </label>
                                <input id="density-slider-ew" type="range" min="1" max="100" value="50" 
                                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
                            </div>
                        </div>
                    </div>

                    <!-- Card: Control de Modo -->
                    <div class="w-full md:w-auto bg-gray-900/50 p-2 rounded-lg flex flex-col justify-center items-center">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2 text-center">Modo</h3>
                        <div class="flex items-center justify-around w-full gap-4">
                            <div class="text-center">
                                <div class="flex items-center justify-center gap-2">
                                    <div id="status-dot" class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></div>
                                    <span id="status-text" class="font-bold text-sm">INTELIGENTE</span>
                                </div>
                            </div>
                            <button id="mode-btn" 
                                    class="px-3 py-1.5 rounded-lg font-bold transition-all bg-cyan-600 hover:bg-cyan-500 text-white shadow text-sm border-b-2 border-cyan-800 active:border-b-0 active:translate-y-0.5 whitespace-nowrap">
                                Cambiar
                            </button>
                        </div>
                    </div>

                </div>
            </div>

        </div>
    </div>


    <!-- Lógica Principal -->
    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

        // --- CONFIGURACIÓN GEOMÉTRICA (BASADO EN IMAGEN) ---
        const ROAD_WIDTH_V = 40; // Ancho calle Vertical (N-S)
        const ROAD_WIDTH_H = 40; // Ancho avenida Horizontal (E-O)
        const MEDIAN_WIDTH = 4;
        const ROAD_LENGTH = 250; 
        const SIMULATION_SPEED = 0.3; 
        const SIDEWALK_WIDTH = 10;
        const CROSSWALK_WIDTH = 4;
        
        // --- CÁLCULO DE CARRILES Y LÍNEAS DE DETENCIÓN ---
        const LANE_WIDTH_V = (ROAD_WIDTH_V - MEDIAN_WIDTH) / 2;
        const LANE_WIDTH_H = (ROAD_WIDTH_H - MEDIAN_WIDTH) / 2;
        const LANE_CENTER_V = MEDIAN_WIDTH / 2 + LANE_WIDTH_V / 2; // Distancia del centro de la calle al centro del carril
        const LANE_CENTER_H = MEDIAN_WIDTH / 2 + LANE_WIDTH_H / 2;
        const LANE_OFFSET = LANE_WIDTH_V / 4; // Desplazamiento desde el centro de la vía direccional al centro de un carril
        
        const STOP_LINE_OFFSET = 4;
        const STOP_LINE_N = -ROAD_WIDTH_H / 2 - STOP_LINE_OFFSET; // Para A1 (desde Norte)
        const STOP_LINE_S = ROAD_WIDTH_H / 2 + STOP_LINE_OFFSET;  // Para A5 (desde Sur)
        const STOP_LINE_E = ROAD_WIDTH_V / 2 + STOP_LINE_OFFSET;  // Para A3 (desde Este)
        const STOP_LINE_W = -ROAD_WIDTH_V / 2 - STOP_LINE_OFFSET; // Para A7 (desde Oeste)

        // --- ZONA SENSOR ---
        const SENSOR_ZONE_LEN = 40; 

        // Enumeraciones
        const Direction = { NORTH: 'NORTH', SOUTH: 'SOUTH', EAST: 'EAST', WEST: 'WEST' };
        const LightState = { RED: 'RED', YELLOW: 'YELLOW', GREEN: 'GREEN' };

        // --- CONFIGURACIÓN DE VEHÍCULOS ---
        const VEHICLE_TYPES = {
            CAR: {
                name: 'CAR',
                baseLength: 6.0,
                baseWidth: 2.8,
                maxSpeed: [25, 20], // base, random
                accelFactor: [0.08, 0.02], // How quickly it reaches target speed
                decelFactor: [0.2, 0.05],  // How quickly it brakes
                colorPool: [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316, 0x64748b]
            },
            TRUCK: {
                name: 'TRUCK',
                baseLength: 10.5,
                baseWidth: 3.2,
                maxSpeed: [20, 15],
                accelFactor: [0.04, 0.01],
                decelFactor: [0.15, 0.05],
                colorPool: [0x4b5563, 0x78716c, 0x064e3b, 0x92400e]
            },
            BUS: {
                name: 'BUS',
                baseLength: 12.0,
                baseWidth: 3.4,
                maxSpeed: [18, 12],
                accelFactor: [0.04, 0.01],
                decelFactor: [0.12, 0.04],
                colorPool: [0xffffff, 0xfde047, 0xbe123c, 0x2563eb]
            },
            MOTORCYCLE: {
                name: 'MOTORCYCLE',
                baseLength: 3.5,
                baseWidth: 1.2,
                maxSpeed: [35, 25],
                accelFactor: [0.15, 0.05],
                decelFactor: [0.25, 0.05],
                colorPool: [0xdc2626, 0x1d4ed8, 0x000000, 0xeeeeee]
            }
        };
        
        // Variables Globales
        let scene, camera, renderer, clock;
        let cars = [];
        let densityNS = 50, densityEW = 50;
        let isSmartMode = true;
        let controller;
        let nextSpawnTimeNS = 0, nextSpawnTimeEW = 0;
        
        // Variables para UI/UX
        const sensorVisuals = {};
        const pressureBars = {};
        const nextGreenIndicators = {};
        const sensorFlashState = {};
        let previousCounts = { a1: 0, a3: 0, a5: 0, a7: 0 };


        // Elementos DOM
        const counters = {
            a1: { el: document.getElementById('counter-a1'), val: document.getElementById('valA1') },
            a3: { el: document.getElementById('counter-a3'), val: document.getElementById('valA3') },
            a5: { el: document.getElementById('counter-a5'), val: document.getElementById('valA5') },
            a7: { el: document.getElementById('counter-a7'), val: document.getElementById('valA7') }
        };
        const elDensityValNS = document.getElementById('density-val-ns');
        const elDensityValEW = document.getElementById('density-val-ew');
        const elStatusText = document.getElementById('status-text');
        const elStatusDot = document.getElementById('status-dot');
        
        class TrafficController {
            constructor(scene) {
                this.stateV = LightState.GREEN; // North-South
                this.stateH = LightState.RED;   // East-West
                this.timerV = 0; this.timerH = 0; this.cycleTimer = 0;
                this.transitioning = false;

                this.MIN_GREEN = 3.0; this.MAX_GREEN = 12.0;
                this.YELLOW_TIME = 1.0; 
                this.PRE_GREEN_YELLOW_TIME = 1.0;
                this.FIXED_TIME = 20.0; 

                this.buildInfrastructure(scene);          
            }

            buildInfrastructure(scene) {
                const createTrafficLight = (x, z, rotation) => {
                    const group = new THREE.Group();
                    const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
                    const housing = new THREE.Mesh(new THREE.BoxGeometry(3.5, 5, 3.5), housingMat);

                    const bulbMat = new THREE.MeshStandardMaterial({ 
                        color: 0x111111,
                        emissive: 0x111111,
                        emissiveIntensity: 0,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const colorBulb = new THREE.Mesh(new THREE.SphereGeometry(1.1, 16, 16), bulbMat);
                    colorBulb.position.set(0, 0, 1.8);

                    housing.add(colorBulb);
                    group.add(housing);
                    group.position.set(x, 3, z);
                    group.rotation.y = rotation;
                    scene.add(group);
                    return { colorBulb: colorBulb };
                };
                
                const offsetX = ROAD_WIDTH_V / 2 + 3;
                const offsetZ = ROAD_WIDTH_H / 2 + 3;
                
                this.lights = {
                    north: createTrafficLight(-offsetX, -offsetZ, Math.PI),
                    south: createTrafficLight(offsetX, offsetZ, 0),
                    east: createTrafficLight(offsetX, -offsetZ, Math.PI / 2),
                    west: createTrafficLight(-offsetX, offsetZ, -Math.PI / 2)
                };
            }

            animateLights(elapsedTime) {
                const OFF_COLOR = 0x111111;
                const RED_COLOR = 0xff0000;
                const YELLOW_COLOR = 0xffaa00;
                const GREEN_COLOR = 0x00ff00;

                const applyStateToMaterial = (material, state) => {
                    switch(state) {
                        case LightState.GREEN:
                            material.color.setHex(GREEN_COLOR);
                            material.emissive.setHex(GREEN_COLOR);
                            const pulse = (Math.sin(elapsedTime * 5) + 1) / 2; // Varies between 0 and 1
                            material.emissiveIntensity = 1.0 + pulse * 0.5;
                            break;
                        case LightState.RED:
                            material.color.setHex(RED_COLOR);
                            material.emissive.setHex(RED_COLOR);
                            const flicker = Math.random() > 0.96 ? -0.4 : 0; // Occasional flicker
                            material.emissiveIntensity = 1.2 + flicker;
                            break;
                        case LightState.YELLOW:
                            material.color.setHex(YELLOW_COLOR);
                            material.emissive.setHex(YELLOW_COLOR);
                            material.emissiveIntensity = 1.5; // Bright and constant
                            break;
                        default: // OFF
                            material.color.setHex(OFF_COLOR);
                            material.emissive.setHex(OFF_COLOR);
                            material.emissiveIntensity = 0;
                            break;
                    }
                };
                
                applyStateToMaterial(this.lights.north.colorBulb.material, this.stateV);
                applyStateToMaterial(this.lights.south.colorBulb.material, this.stateV);
                applyStateToMaterial(this.lights.east.colorBulb.material, this.stateH);
                applyStateToMaterial(this.lights.west.colorBulb.material, this.stateH);
            }

            switchLight(giveGreenTo) {
                if (this.transitioning || (giveGreenTo === 'V' && this.stateV === LightState.GREEN) || (giveGreenTo === 'H' && this.stateH === LightState.GREEN)) return;
                this.transitioning = true;
                
                if (giveGreenTo === 'V') nextGreenIndicators.v.visible = true; else nextGreenIndicators.h.visible = true;

                if (this.stateV === LightState.GREEN) { this.stateV = LightState.YELLOW; }
                if (this.stateH === LightState.GREEN) { this.stateH = LightState.YELLOW; }
                
                setTimeout(() => {
                    if (giveGreenTo === 'V') { 
                        this.stateH = LightState.RED; 
                        this.stateV = LightState.YELLOW;
                    } else { 
                        this.stateV = LightState.RED; 
                        this.stateH = LightState.YELLOW; 
                    }
                    
                    setTimeout(() => {
                        nextGreenIndicators.v.visible = false;
                        nextGreenIndicators.h.visible = false;
                        this.stateV = (giveGreenTo === 'V') ? LightState.GREEN : LightState.RED;
                        this.stateH = (giveGreenTo === 'H') ? LightState.GREEN : LightState.RED;
                        
                        this.timerV = 0; this.timerH = 0;
                        this.transitioning = false;
                    }, this.PRE_GREEN_YELLOW_TIME * 1000 / SIMULATION_SPEED);

                }, this.YELLOW_TIME * 1000 / SIMULATION_SPEED);
            }

            updateLogic(dt, counts) {
                this.timerV += dt;
                this.timerH += dt;

                if (this.transitioning) { return; }

                if (isSmartMode) {
                    const totalV = counts.a1 + counts.a5;
                    const totalH = counts.a3 + counts.a7;
                    if (this.stateV === LightState.GREEN && this.timerV > this.MIN_GREEN) {
                        if ((totalH > totalV) || (totalV === 0 && totalH > 0) || this.timerV > this.MAX_GREEN) this.switchLight('H');
                    } else if (this.stateH === LightState.GREEN && this.timerH > this.MIN_GREEN) {
                        if ((totalV > totalH) || (totalH === 0 && totalV > 0) || this.timerH > this.MAX_GREEN) this.switchLight('V');
                    }
                } else {
                    if (this.stateV === LightState.GREEN && this.timerV > this.FIXED_TIME) this.switchLight('H');
                    else if (this.stateH === LightState.GREEN && this.timerH > this.FIXED_TIME) this.switchLight('V');
                }
            }
        }

        function setupInteractivePanel() {
            const panel = document.getElementById('control-panel-wrapper');
            if (!panel) return;

            const uiPanel = panel.querySelector('.ui-panel');
            if (!uiPanel) return;

            // --- Funcionalidad de Redimensionar ---
            const resizeHandle = document.createElement('div');
            resizeHandle.style.position = 'absolute';
            resizeHandle.style.bottom = '1px';
            resizeHandle.style.right = '1px';
            resizeHandle.style.width = '16px';
            resizeHandle.style.height = '16px';
            resizeHandle.style.cursor = 'nwse-resize';
            resizeHandle.style.zIndex = '10';
            resizeHandle.style.borderBottom = '3px solid #6b7280';
            resizeHandle.style.borderRight = '3px solid #6b7280';
            resizeHandle.style.boxSizing = 'border-box';
            uiPanel.appendChild(resizeHandle);
            
            const onStartResize = (e) => {
                e.stopPropagation();
                e.preventDefault();
                document.body.style.userSelect = 'none';
                
                const rect = panel.getBoundingClientRect();
                const initialWidth = rect.width;
                const initialHeight = rect.height;
                const initialMouseX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const initialMouseY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

                const onResize = (moveEvent) => {
                    const clientX = moveEvent.type === 'touchmove' ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const clientY = moveEvent.type === 'touchmove' ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    const dx = clientX - initialMouseX;
                    const dy = clientY - initialMouseY;
                    panel.style.width = `${initialWidth + dx}px`;
                    panel.style.height = `${initialHeight + dy}px`;
                };

                const onStopResize = () => {
                    document.body.style.userSelect = '';
                    window.removeEventListener('mousemove', onResize);
                    window.removeEventListener('touchmove', onResize);
                    window.removeEventListener('mouseup', onStopResize);
                    window.removeEventListener('touchend', onStopResize);
                };
                
                window.addEventListener('mousemove', onResize);
                window.addEventListener('touchmove', onResize, { passive: false });
                window.addEventListener('mouseup', onStopResize, { once: true });
                window.addEventListener('touchend', onStopResize, { once: true });
            };

            resizeHandle.addEventListener('mousedown', onStartResize);
            resizeHandle.addEventListener('touchstart', onStartResize, { passive: false });

            // --- Funcionalidad de Minimizar/Maximizar ---
            const toggleBtn = document.getElementById('toggle-panel-btn');
            const toggleIcon = document.getElementById('toggle-icon');
            const collapsiblePart = document.getElementById('collapsible-controls');
            toggleBtn.addEventListener('click', () => {
                panel.classList.toggle('minimized');
                collapsiblePart.classList.toggle('collapsed');
                toggleIcon.style.transform = collapsiblePart.classList.contains('collapsed') ? 'rotate(180deg)' : 'rotate(0deg)';
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); // White background
            const container = document.getElementById('canvas-container');

            const aspect = window.innerWidth / window.innerHeight;
            const d = 80;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(0, 100, 0); 
            camera.lookAt(0, 0, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // --- Iluminación para Modo Claro con Sombras ---
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(-80, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);


            createGround(); 
            createRoads(); 
            createSidewalks();
            createCrosswalks();
            createSensorVisuals();
            createPressureBars();
            createNextGreenIndicators();
            createDashedBorders();
            createMedianBorders();
            createLaneMarkings();

            controller = new TrafficController(scene); 
            window.addEventListener('resize', onResize);
            document.getElementById('density-slider-ns').addEventListener('input', (e) => { densityNS = parseInt(e.target.value); elDensityValNS.innerText = densityNS + '%'; });
            document.getElementById('density-slider-ew').addEventListener('input', (e) => { densityEW = parseInt(e.target.value); elDensityValEW.innerText = densityEW + '%'; });
            document.getElementById('mode-btn').addEventListener('click', () => {
                isSmartMode = !isSmartMode;
                elStatusText.innerText = isSmartMode ? 'INTELIGENTE' : 'SECUENCIA';
                elStatusDot.classList.toggle('bg-green-500', isSmartMode);
                elStatusDot.classList.toggle('bg-yellow-500', !isSmartMode);
                controller.timerV = 0;
                controller.timerH = 0;
            });
            
            // UI -> 3D Interactivity
            Object.keys(counters).forEach(key => {
                const sensorMesh = sensorVisuals[key];
                const counterEl = counters[key].el;
                if(sensorMesh && counterEl) {
                    counterEl.addEventListener('mouseenter', () => {
                        sensorMesh.material.color.setHex(0x00ffff); // Bright cyan
                        sensorMesh.material.opacity = 0.6;
                    });
                     counterEl.addEventListener('mouseleave', () => {
                        sensorMesh.material.color.setHex(0x00bcd4); // Original cyan
                        sensorMesh.material.opacity = 0.35;
                    });
                }
            });

            setupInteractivePanel();

            const loader = new FontLoader();
            loader.load('https://raw.githack.com/mrdoob/three.js/master/examples/fonts/helvetiker_bold.typeface.json', font => {
                createStreetLabels(font);
            });

            clock = new THREE.Clock();
            animate();
        }

        function createGround() {
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000), 
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            scene.add(ground);

            const grid = new THREE.GridHelper(2000, 100, 0xcccccc, 0xdddddd);
            grid.position.y = -0.09;
            scene.add(grid);
        }
        
        function createSidewalks() {
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const height = 0.2;
            const sidewalkVLength = (ROAD_LENGTH - ROAD_WIDTH_H) / 2;
            const sidewalkHLength = (ROAD_LENGTH - ROAD_WIDTH_V) / 2;

            const createSidewalkSegment = (w, h, x, z) => {
                const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(w, height, h), sidewalkMat);
                sidewalk.position.set(x, height / 2, z);
                sidewalk.receiveShadow = true;
                scene.add(sidewalk);
            };
            
            // Vertical Sidewalks
            createSidewalkSegment(SIDEWALK_WIDTH, sidewalkVLength, ROAD_WIDTH_V/2 + SIDEWALK_WIDTH/2, ROAD_WIDTH_H/2 + sidewalkVLength/2);
            createSidewalkSegment(SIDEWALK_WIDTH, sidewalkVLength, ROAD_WIDTH_V/2 + SIDEWALK_WIDTH/2, -ROAD_WIDTH_H/2 - sidewalkVLength/2);
            createSidewalkSegment(SIDEWALK_WIDTH, sidewalkVLength, -ROAD_WIDTH_V/2 - SIDEWALK_WIDTH/2, ROAD_WIDTH_H/2 + sidewalkVLength/2);
            createSidewalkSegment(SIDEWALK_WIDTH, sidewalkVLength, -ROAD_WIDTH_V/2 - SIDEWALK_WIDTH/2, -ROAD_WIDTH_H/2 - sidewalkVLength/2);
            
            // Horizontal Sidewalks
            createSidewalkSegment(sidewalkHLength, SIDEWALK_WIDTH, ROAD_WIDTH_V/2 + sidewalkHLength/2, ROAD_WIDTH_H/2 + SIDEWALK_WIDTH/2);
            createSidewalkSegment(sidewalkHLength, SIDEWALK_WIDTH, ROAD_WIDTH_V/2 + sidewalkHLength/2, -ROAD_WIDTH_H/2 - SIDEWALK_WIDTH/2);
            createSidewalkSegment(sidewalkHLength, SIDEWALK_WIDTH, -ROAD_WIDTH_V/2 - sidewalkHLength/2, ROAD_WIDTH_H/2 + SIDEWALK_WIDTH/2);
            createSidewalkSegment(sidewalkHLength, SIDEWALK_WIDTH, -ROAD_WIDTH_V/2 - sidewalkHLength/2, -ROAD_WIDTH_H/2 - SIDEWALK_WIDTH/2);
            
            // Corner Sidewalks
            createSidewalkSegment(SIDEWALK_WIDTH, SIDEWALK_WIDTH, ROAD_WIDTH_V/2 + SIDEWALK_WIDTH/2, ROAD_WIDTH_H/2 + SIDEWALK_WIDTH/2);
            createSidewalkSegment(SIDEWALK_WIDTH, SIDEWALK_WIDTH, ROAD_WIDTH_V/2 + SIDEWALK_WIDTH/2, -ROAD_WIDTH_H/2 - SIDEWALK_WIDTH/2);
            createSidewalkSegment(SIDEWALK_WIDTH, SIDEWALK_WIDTH, -ROAD_WIDTH_V/2 - SIDEWALK_WIDTH/2, ROAD_WIDTH_H/2 + SIDEWALK_WIDTH/2);
            createSidewalkSegment(SIDEWALK_WIDTH, SIDEWALK_WIDTH, -ROAD_WIDTH_V/2 - SIDEWALK_WIDTH/2, -ROAD_WIDTH_H/2 - SIDEWALK_WIDTH/2);
        }

        function createCrosswalks() {
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const stripeGeo = new THREE.PlaneGeometry(1.5, CROSSWALK_WIDTH);

            const createStripe = (x, z, rotation) => {
                const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                stripe.position.set(x, 0.015, z);
                stripe.rotation.x = -Math.PI / 2;
                stripe.rotation.z = rotation;
                scene.add(stripe);
            };

            const WV_HALF = ROAD_WIDTH_V / 2;
            const WH_HALF = ROAD_WIDTH_H / 2;
            
            // Vertical Crosswalks (East and West sides) - Spanning full ROAD_WIDTH_V
            for (let i = -WV_HALF; i < WV_HALF; i += 3) {
                createStripe(WH_HALF + STOP_LINE_OFFSET / 2, i, Math.PI / 2);
                createStripe(-WH_HALF - STOP_LINE_OFFSET / 2, i, Math.PI / 2);
            }
            
            // Horizontal Crosswalks (North and South sides) - Spanning full ROAD_WIDTH_H
            for (let i = -WH_HALF; i < WH_HALF; i += 3) {
                createStripe(i, WV_HALF + STOP_LINE_OFFSET / 2, 0);
                createStripe(i, -WV_HALF - STOP_LINE_OFFSET / 2, 0);
            }
        }


        function createRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050,
                roughness: 0.8,
                metalness: 0.0,
            });

            const roadV = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH_V, ROAD_LENGTH), roadMaterial);
            roadV.rotation.x = -Math.PI / 2;
            roadV.receiveShadow = true;
            scene.add(roadV);
            const roadH = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LENGTH, ROAD_WIDTH_H), roadMaterial);
            roadH.rotation.x = -Math.PI / 2;
            roadH.receiveShadow = true;
            scene.add(roadH);

            const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const createStopLine = (w, h, x, z) => {
                const line = new THREE.Mesh(new THREE.PlaneGeometry(w, h), stopLineMat);
                line.rotation.x = -Math.PI / 2; line.position.set(x, 0.01, z); scene.add(line);
            };
            createStopLine(LANE_WIDTH_V, 1.5, -LANE_CENTER_V, STOP_LINE_N);
            createStopLine(LANE_WIDTH_V, 1.5, LANE_CENTER_V, STOP_LINE_S);
            createStopLine(1.5, LANE_WIDTH_H, STOP_LINE_E, -LANE_CENTER_H);
            createStopLine(1.5, LANE_WIDTH_H, STOP_LINE_W, LANE_CENTER_H);

            const yellow = new THREE.MeshStandardMaterial({ 
                color: 0xfacc15, 
                roughness: 0.8, 
                metalness: 0.1,
            });
            const createMedian = (w, h, x, z, rotation) => {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.PlaneGeometry(w, h), yellow);
                group.add(body);
                const cap1 = new THREE.Mesh(new THREE.CircleGeometry(w/2, 32), yellow);
                cap1.position.y = h/2;
                group.add(cap1);
                const cap2 = new THREE.Mesh(new THREE.CircleGeometry(w/2, 32), yellow);
                cap2.position.y = -h/2;
                group.add(cap2);
                
                group.rotation.x = -Math.PI / 2;
                group.rotation.z = rotation;
                group.position.set(x, 0.02, z);
                scene.add(group);
            };
            
            const segLenV = ROAD_LENGTH/2 - ROAD_WIDTH_H/2;
            createMedian(MEDIAN_WIDTH, segLenV, 0, -ROAD_WIDTH_H/2 - segLenV/2, 0);
            createMedian(MEDIAN_WIDTH, segLenV, 0, ROAD_WIDTH_H/2 + segLenV/2, 0);
            const segLenH = ROAD_LENGTH/2 - ROAD_WIDTH_V/2;
            createMedian(MEDIAN_WIDTH, segLenH, -ROAD_WIDTH_V/2 - segLenH/2, 0, Math.PI/2);
            createMedian(MEDIAN_WIDTH, segLenH, ROAD_WIDTH_V/2 + segLenH/2, 0, Math.PI/2);
        }

         function createDashedBorders() {
            const mat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 2, gapSize: 2 });
            const createBorder = (points) => {
                const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.01, p[1])));
                const line = new THREE.Line(geo, mat);
                line.computeLineDistances();
                scene.add(line);
            };
            const LV = ROAD_LENGTH/2; const LH = ROAD_LENGTH/2;
            const WV = ROAD_WIDTH_V/2; const WH = ROAD_WIDTH_H/2;
            createBorder([[-WV, -LV], [-WV, -WH]]); createBorder([[WV, -LV], [WV, -WH]]);
            createBorder([[-WV, LV], [-WV, WH]]); createBorder([[WV, LV], [WV, WH]]);
            createBorder([[-LH, -WH], [-WV, -WH]]); createBorder([[-LH, WH], [-WV, WH]]);
            createBorder([[LH, -WH], [WV, -WH]]); createBorder([[LH, WH], [WV, WH]]);
        }

        function createMedianBorders() {
            const mat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 1, gapSize: 1.5 });
            const createBorder = (points) => {
                const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.025, p[1])));
                const line = new THREE.Line(geo, mat);
                line.computeLineDistances();
                scene.add(line);
            };
            const MW_HALF = MEDIAN_WIDTH / 2;
            const WH_HALF = ROAD_WIDTH_H / 2;
            const WV_HALF = ROAD_WIDTH_V / 2;
            const RL_HALF = ROAD_LENGTH / 2;

            createBorder([[-MW_HALF, -WH_HALF], [-MW_HALF, -RL_HALF]]);
            createBorder([[MW_HALF, -WH_HALF], [MW_HALF, -RL_HALF]]);
            createBorder([[-MW_HALF, WH_HALF], [-MW_HALF, RL_HALF]]);
            createBorder([[MW_HALF, WH_HALF], [MW_HALF, RL_HALF]]);
            createBorder([[-WV_HALF, -MW_HALF], [-RL_HALF, -MW_HALF]]);
            createBorder([[-WV_HALF, MW_HALF], [-RL_HALF, MW_HALF]]);
            createBorder([[WV_HALF, -MW_HALF], [RL_HALF, -MW_HALF]]);
            createBorder([[WV_HALF, MW_HALF], [RL_HALF, MW_HALF]]);
        }

        function createLaneMarkings() {
            const mat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 3, gapSize: 5, linewidth: 1 });
            const createLine = (points) => {
                const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p[0], 0.03, p[1])));
                const line = new THREE.Line(geo, mat);
                line.computeLineDistances();
                scene.add(line);
            };

            const RL_HALF = ROAD_LENGTH / 2;
            const WH_HALF = ROAD_WIDTH_H / 2;
            const WV_HALF = ROAD_WIDTH_V / 2;

            createLine([[LANE_CENTER_V, RL_HALF], [LANE_CENTER_V, WH_HALF]]);
            createLine([[-LANE_CENTER_V, -RL_HALF], [-LANE_CENTER_V, -WH_HALF]]);
            createLine([[-RL_HALF, LANE_CENTER_H], [-WV_HALF, LANE_CENTER_H]]);
            createLine([[RL_HALF, -LANE_CENTER_H], [WV_HALF, -LANE_CENTER_H]]);
            createLine([[LANE_CENTER_V, -WH_HALF], [LANE_CENTER_V, -RL_HALF]]);
            createLine([[-LANE_CENTER_V, WH_HALF], [-LANE_CENTER_V, RL_HALF]]);
            createLine([[WV_HALF, LANE_CENTER_H], [RL_HALF, LANE_CENTER_H]]);
            createLine([[-WV_HALF, -LANE_CENTER_H], [-RL_HALF, -LANE_CENTER_H]]);
        }
        
        function createSensorVisuals() {
            const createSensorPlane = (w, h, x, z, key) => {
                const mat = new THREE.MeshBasicMaterial({ color: 0x00bcd4, transparent: true, opacity: 0.35, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, 0.03, z);
                scene.add(mesh);
                sensorVisuals[key] = mesh;
            };

            createSensorPlane(LANE_WIDTH_V, SENSOR_ZONE_LEN, -LANE_CENTER_V, STOP_LINE_N - SENSOR_ZONE_LEN / 2, 'a1');
            createSensorPlane(LANE_WIDTH_V, SENSOR_ZONE_LEN, LANE_CENTER_V, STOP_LINE_S + SENSOR_ZONE_LEN / 2, 'a5');
            createSensorPlane(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_E + SENSOR_ZONE_LEN / 2, -LANE_CENTER_H, 'a3');
            createSensorPlane(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_W - SENSOR_ZONE_LEN / 2, LANE_CENTER_H, 'a7');

            const createTarget = (name, x, y, z) => {
                const target = new THREE.Object3D();
                target.name = `target${name.toUpperCase()}`;
                target.position.set(x, y, z);
                scene.add(target);
            };
            
            const height = 1; 
            const sideOffset = 5;
            const distanceFromStopLine = 10; 

            createTarget('A1', -ROAD_WIDTH_V / 2 - sideOffset, height, STOP_LINE_N - distanceFromStopLine);
            createTarget('A3', STOP_LINE_E + distanceFromStopLine, height, -ROAD_WIDTH_H / 2 - sideOffset);
            createTarget('A5', ROAD_WIDTH_V / 2 + sideOffset, height, STOP_LINE_S + distanceFromStopLine);
            createTarget('A7', STOP_LINE_W - distanceFromStopLine, height, ROAD_WIDTH_H / 2 + sideOffset);
        }

        function createPressureBars() {
            const createBar = (w, h, x, z, key) => {
                const mat = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.6 });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, 0.04, z);
                
                if (key === 'a1' || key === 'a5') {
                    mesh.scale.y = 0.01;
                } else {
                    mesh.scale.x = 0.01;
                }

                scene.add(mesh);
                pressureBars[key] = mesh;
            };

            createBar(LANE_WIDTH_V, SENSOR_ZONE_LEN, -LANE_CENTER_V, STOP_LINE_N - SENSOR_ZONE_LEN / 2, 'a1');
            createBar(LANE_WIDTH_V, SENSOR_ZONE_LEN, LANE_CENTER_V, STOP_LINE_S + SENSOR_ZONE_LEN / 2, 'a5');
            createBar(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_E + SENSOR_ZONE_LEN / 2, -LANE_CENTER_H, 'a3');
            createBar(SENSOR_ZONE_LEN, LANE_WIDTH_H, STOP_LINE_W - SENSOR_ZONE_LEN / 2, LANE_CENTER_H, 'a7');
        }

        function createNextGreenIndicators() {
            const mat = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5 });
            const createArrow = () => {
                const shape = new THREE.Shape();
                shape.moveTo(0, 3);
                shape.lineTo(2, 0);
                shape.lineTo(1, 0);
                shape.lineTo(1, -3);
                shape.lineTo(-1, -3);
                shape.lineTo(-1, 0);
                shape.lineTo(-2, 0);
                shape.closePath();
                return new THREE.Mesh(new THREE.ShapeGeometry(shape), mat);
            };
            
            const groupV = new THREE.Group();
            const arrowN = createArrow();
            arrowN.position.set(-LANE_CENTER_V, 0.05, STOP_LINE_N - 10);
            arrowN.rotation.x = -Math.PI / 2;
            const arrowS = createArrow();
            arrowS.position.set(LANE_CENTER_V, 0.05, STOP_LINE_S + 10);
            arrowS.rotation.x = -Math.PI / 2;
            arrowS.rotation.z = Math.PI;
            groupV.add(arrowN, arrowS);
            groupV.visible = false;
            scene.add(groupV);
            nextGreenIndicators.v = groupV;
            
            const groupH = new THREE.Group();
            const arrowE = createArrow();
            arrowE.position.set(STOP_LINE_E + 10, 0.05, -LANE_CENTER_H);
            arrowE.rotation.x = -Math.PI / 2;
            arrowE.rotation.z = -Math.PI / 2;
            const arrowW = createArrow();
            arrowW.position.set(STOP_LINE_W - 10, 0.05, LANE_CENTER_H);
            arrowW.rotation.x = -Math.PI / 2;
            arrowW.rotation.z = Math.PI / 2;
            groupH.add(arrowE, arrowW);
            groupH.visible = false;
            scene.add(groupH);
            nextGreenIndicators.h = groupH;
        }


        function createStreetLabels(font) {
            const mat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const create = (text, x, z, rot=0) => {
                const geo = new TextGeometry(text, { font: font, size: 3, height: 0.1 }); geo.center();
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI/2;
                mesh.rotation.z = rot;
                mesh.position.set(x, 0.1, z);
                scene.add(mesh);
            };
            const WV = ROAD_WIDTH_V/2; const WH = ROAD_WIDTH_H/2;
            
            // Entrances
            create('A1', -LANE_CENTER_V, -WH-8); 
            create('A3', WV+8, -LANE_CENTER_H, -Math.PI/2);
            create('A5', LANE_CENTER_V, WH+8);
            create('A7', -WV-8, LANE_CENTER_H, Math.PI/2);

            // Exits
            create('A2', LANE_CENTER_V, -WH-8);
            create('A4', WV+8, LANE_CENTER_H, -Math.PI/2);
            create('A6', -LANE_CENTER_V, WH+8);
            create('A8', -WV-8, -LANE_CENTER_H, Math.PI/2);
        }
        
        function createVehicleMesh(vehicleType, color, width, length) {
            const grp = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.5 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.1 });

            if (vehicleType.name === 'CAR') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(width, 1.5, length), mat);
                body.position.y = 0.75;
                grp.add(body);
                const top = new THREE.Mesh(new THREE.BoxGeometry(width * 0.85, 0.8, length * 0.55), darkMat);
                top.position.set(0, 1.9, -0.2);
                grp.add(top);
            } else if (vehicleType.name === 'TRUCK') {
                const cab = new THREE.Mesh(new THREE.BoxGeometry(width, 2.2, length * 0.4), mat);
                cab.position.set(0, 1.1, length * 0.3);
                grp.add(cab);
                const trailer = new THREE.Mesh(new THREE.BoxGeometry(width * 0.95, 2.5, length * 0.65), darkMat);
                trailer.position.set(0, 1.25, -length * 0.175);
                grp.add(trailer);
            } else if (vehicleType.name === 'BUS') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(width, 2.8, length), mat);
                body.position.y = 1.4;
                grp.add(body);
                const windows = new THREE.Mesh(new THREE.BoxGeometry(width * 1.01, 1.4, length * 0.85), darkMat);
                windows.position.set(0, 2.101, 0);
                grp.add(windows);
            } else if (vehicleType.name === 'MOTORCYCLE') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(width, 0.8, length), mat);
                body.position.y = 0.6;
                grp.add(body);
                const seat = new THREE.Mesh(new THREE.BoxGeometry(width * 0.8, 0.4, length * 0.4), darkMat);
                seat.position.set(0, 1.2, -length * 0.1);
                grp.add(seat);
            }
            
            grp.traverse(child => { if(child.isMesh) { child.castShadow = true; } });

            const lightY = 0.85;

            // Headlights & Taillights
            const headLightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xdd0000, emissive: 0xdd0000, emissiveIntensity: 0.4, roughness: 0.8 });
            const lightWidth = Math.max(0.2, width * 0.2);

            const leftHeadLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), headLightMat);
            leftHeadLight.position.set(-width / 2.5, lightY, length / 2 + 0.01);
            grp.add(leftHeadLight);

            const rightHeadLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), headLightMat);
            rightHeadLight.position.set(width / 2.5, lightY, length / 2 + 0.01);
            grp.add(rightHeadLight);

            const leftTailLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), tailLightMat);
            leftTailLight.position.set(-width / 2.5, lightY, -length / 2 - 0.01);
            leftTailLight.name = "leftTailLight";
            grp.add(leftTailLight);
            
            const rightTailLight = new THREE.Mesh(new THREE.BoxGeometry(lightWidth, 0.5, 0.2), tailLightMat.clone());
            rightTailLight.position.set(width / 2.5, lightY, -length / 2 - 0.01);
            rightTailLight.name = "rightTailLight";
            grp.add(rightTailLight);

            // Indicators
            const indicatorMat = new THREE.MeshBasicMaterial({ color: 0xffa500 }); // Amber
            const indicatorSize = { w: 0.4, h: 0.5, d: 0.4 };
            const indicatorGeo = new THREE.BoxGeometry(indicatorSize.w, indicatorSize.h, indicatorSize.d);

            const indicatorFR = new THREE.Mesh(indicatorGeo, indicatorMat.clone());
            indicatorFR.position.set(width / 2 + 0.05, lightY, length / 2 - indicatorSize.d);
            indicatorFR.name = "indicator_fr";
            indicatorFR.visible = false;
            grp.add(indicatorFR);

            const indicatorRR = new THREE.Mesh(indicatorGeo, indicatorMat.clone());
            indicatorRR.position.set(width / 2 + 0.05, lightY, -length / 2 + indicatorSize.d);
            indicatorRR.name = "indicator_rr";
            indicatorRR.visible = false;
            grp.add(indicatorRR);

            const indicatorFL = new THREE.Mesh(indicatorGeo, indicatorMat.clone());
            indicatorFL.position.set(-width / 2 - 0.05, lightY, length / 2 - indicatorSize.d);
            indicatorFL.name = "indicator_fl";
            indicatorFL.visible = false;
            grp.add(indicatorFL);

            const indicatorRL = new THREE.Mesh(indicatorGeo, indicatorMat.clone());
            indicatorRL.position.set(-width / 2 - 0.05, lightY, -length / 2 + indicatorSize.d);
            indicatorRL.name = "indicator_rl";
            indicatorRL.visible = false;
            grp.add(indicatorRL);

            return grp;
        }

        function startTurn(c) {
            c.isTurning = true;
            c.wantsToTurn = false;
            c.turnProgress = 0;

            const W_V_HALF = ROAD_WIDTH_V / 2;
            const W_H_HALF = ROAD_WIDTH_H / 2;

            let start, end, control;

            // Note: Directions are named based on destination, not origin
            // NORTH: Northbound (from A5), SOUTH: Southbound (from A1) etc.
            switch(c.direction) {
                case Direction.SOUTH: // A1 -> A8 (Southbound to Westbound)
                    start = new THREE.Vector3(-LANE_CENTER_V - LANE_OFFSET, 0, -W_H_HALF);
                    end = new THREE.Vector3(-W_V_HALF, 0, -LANE_CENTER_H - LANE_OFFSET);
                    control = new THREE.Vector3(start.x, 0, end.z);
                    break;
                case Direction.WEST: // A3 -> A2 (Westbound to Northbound)
                    start = new THREE.Vector3(W_V_HALF, 0, -LANE_CENTER_H - LANE_OFFSET);
                    end = new THREE.Vector3(LANE_CENTER_V + LANE_OFFSET, 0, -W_H_HALF);
                    control = new THREE.Vector3(end.x, 0, start.z);
                    break;
                case Direction.NORTH: // A5 -> A4 (Northbound to Eastbound)
                    start = new THREE.Vector3(LANE_CENTER_V + LANE_OFFSET, 0, W_H_HALF);
                    end = new THREE.Vector3(W_V_HALF, 0, LANE_CENTER_H + LANE_OFFSET);
                    control = new THREE.Vector3(start.x, 0, end.z);
                    break;
                case Direction.EAST: // A7 -> A6 (Eastbound to Southbound)
                    start = new THREE.Vector3(-W_V_HALF, 0, LANE_CENTER_H + LANE_OFFSET);
                    end = new THREE.Vector3(-LANE_CENTER_V - LANE_OFFSET, 0, W_H_HALF);
                    control = new THREE.Vector3(end.x, 0, start.z);
                    break;
            }
            
            if (start && end && control) {
                c.turnPath = new THREE.QuadraticBezierCurve3(start, control, end);
                // --- REMOVED: Position snapping that caused the jump ---
            } else {
                c.isTurning = false;
                c.destinationDirection = null;
            }
        }

        function updateTurn(c, dt) {
            if (!c.turnPath) {
                c.isTurning = false; return;
            }

            const turnTargetSpeed = c.maxSpeed * 0.9;
            c.speed += (turnTargetSpeed - c.speed) * (turnTargetSpeed < c.speed ? c.decelFactor : c.accelFactor);
            if (c.speed < 0) c.speed = 0;

            const distanceToMove = c.speed * dt;
            const pathLength = c.turnPath.getLength();
            const progressIncrement = distanceToMove / pathLength;
            c.turnProgress += progressIncrement;

            if (c.turnProgress >= 1) {
                c.isTurning = false;
                c.blinkerState = 'off'; // Turn off blinker
                c.blinkerTimer = 0;
                if (c.indicators.fr) c.indicators.fr.visible = false;
                if (c.indicators.rr) c.indicators.rr.visible = false;
                if (c.indicators.fl) c.indicators.fl.visible = false;
                if (c.indicators.rl) c.indicators.rl.visible = false;
                
                const endPoint = c.turnPath.getPointAt(1);
                c.mesh.position.copy(endPoint);
                c.direction = c.destinationDirection;
                c.destinationDirection = null;
                c.turnPath = null;
                
                // Update rotation to match new direction
                switch(c.direction) {
                    case Direction.NORTH: c.mesh.rotation.y = Math.PI; break;    // Northbound faces -Z
                    case Direction.EAST: c.mesh.rotation.y = Math.PI/2; break;   // Eastbound faces +X
                    case Direction.SOUTH: c.mesh.rotation.y = 0; break;           // Southbound faces +Z
                    case Direction.WEST: c.mesh.rotation.y = -Math.PI/2; break;  // Westbound faces -X
                }
            } else {
                const newPos = c.turnPath.getPointAt(c.turnProgress);
                const tangent = c.turnPath.getTangentAt(c.turnProgress).normalize();
                c.mesh.position.copy(newPos);
                
                // --- NEW: Smoothly interpolate rotation to prevent snapping ---
                const targetRotation = Math.atan2(tangent.x, tangent.z);
                const rotationSpeed = 0.25; // Controls how quickly the car's rotation adjusts
                
                // Handle angle wrapping around PI and -PI for smooth interpolation
                let rotationDifference = targetRotation - c.mesh.rotation.y;
                while (rotationDifference < -Math.PI) rotationDifference += 2 * Math.PI;
                while (rotationDifference > Math.PI) rotationDifference -= 2 * Math.PI;

                c.mesh.rotation.y += rotationDifference * rotationSpeed;
            }
        }
        
        function spawnVehicle(axis) {
            const rand = Math.random();
            let vehicleType;
            if (rand < 0.70) vehicleType = VEHICLE_TYPES.CAR;
            else if (rand < 0.83) vehicleType = VEHICLE_TYPES.TRUCK;
            else if (rand < 0.85) vehicleType = VEHICLE_TYPES.BUS;
            else vehicleType = VEHICLE_TYPES.MOTORCYCLE;

            const lengthMultiplier = 0.9 + Math.random() * 0.2;
            const widthMultiplier = 0.95 + Math.random() * 0.1;
            const actualLength = vehicleType.baseLength * lengthMultiplier;
            const actualWidth = vehicleType.baseWidth * widthMultiplier;

            const vehicle = { 
                mesh: null, 
                indicators: null,
                tailLightMaterials: [],
                isBraking: false,
                direction: null, 
                speed: 0, 
                maxSpeed: vehicleType.maxSpeed[0] + Math.random() * vehicleType.maxSpeed[1],
                accelFactor: vehicleType.accelFactor[0] + Math.random() * vehicleType.accelFactor[1],
                decelFactor: vehicleType.decelFactor[0] + Math.random() * vehicleType.decelFactor[1],
                followingTime: 0.8 + Math.random() * 0.7,
                actualLength: actualLength,
                type: vehicleType.name,
                wantsToTurn: false,
                isTurning: false,
                turnPath: null,
                turnProgress: 0,
                destinationDirection: null,
                blinkerState: 'off',
                blinkerTimer: 0
            };

            const canTurn = vehicle.type === 'CAR' || vehicle.type === 'MOTORCYCLE';
            if (canTurn && Math.random() < 0.35) {
                vehicle.wantsToTurn = true;
            }

            let x = 0, z = 0, rot = 0;
            const L = ROAD_LENGTH / 2 + 10;
            
            let spawnCase;
            if (axis === 'NS') {
                spawnCase = Math.random() < 0.5 ? 0 : 2; // From A1 (South) or A5 (North)
            } else { // 'EW'
                spawnCase = Math.random() < 0.5 ? 1 : 3; // From A3 (West) or A7 (East)
            }

            // Note: Directions are named based on destination, not origin
            // A1: Southbound, A3: Westbound, A5: Northbound, A7: Eastbound
            switch(spawnCase) {
                case 0: // From A1 (Southbound)
                    vehicle.direction = Direction.SOUTH; 
                    rot = 0; // Faces +Z
                    z = -L;
                    if (vehicle.wantsToTurn) { // A1 -> A8 (to Westbound)
                        x = -LANE_CENTER_V - LANE_OFFSET; // Outer lane for right turn
                        vehicle.destinationDirection = Direction.WEST;
                    } else {
                        x = (Math.random() < 0.5 ? -LANE_CENTER_V - LANE_OFFSET : -LANE_CENTER_V + LANE_OFFSET); 
                    }
                    break;
                case 1: // From A3 (Westbound)
                    vehicle.direction = Direction.WEST;
                    rot = -Math.PI/2; // Faces -X
                    x = L;
                    if (vehicle.wantsToTurn) { // A3 -> A2 (to Northbound)
                        z = -LANE_CENTER_H - LANE_OFFSET; // Outer lane
                        vehicle.destinationDirection = Direction.NORTH;
                    } else {
                         z = (Math.random() < 0.5 ? -LANE_CENTER_H - LANE_OFFSET : -LANE_CENTER_H + LANE_OFFSET); 
                    }
                    break;
                case 2: // From A5 (Northbound)
                    vehicle.direction = Direction.NORTH;
                    rot = Math.PI; // Faces -Z
                    z = L;
                    if (vehicle.wantsToTurn) { // A5 -> A4 (to Eastbound)
                        x = LANE_CENTER_V + LANE_OFFSET; // Outer lane
                        vehicle.destinationDirection = Direction.EAST;
                    } else {
                        x = (Math.random() < 0.5 ? LANE_CENTER_V - LANE_OFFSET : LANE_CENTER_V + LANE_OFFSET); 
                    }
                    break;
                case 3: // From A7 (Eastbound)
                    vehicle.direction = Direction.EAST;
                    rot = Math.PI/2; // Faces +X
                    x = -L;
                    if (vehicle.wantsToTurn) { // A7 -> A6 (to Southbound)
                       z = LANE_CENTER_H + LANE_OFFSET; // Outer lane
                       vehicle.destinationDirection = Direction.SOUTH;
                    } else {
                        z = (Math.random() < 0.5 ? LANE_CENTER_H - LANE_OFFSET : LANE_CENTER_H + LANE_OFFSET); 
                    }
                    break;
            }

            if (cars.some(c => c.mesh.position.distanceTo(new THREE.Vector3(x,0,z)) < c.actualLength * 2.5)) return;
            
            const color = vehicleType.colorPool[Math.floor(Math.random() * vehicleType.colorPool.length)];
            const mesh = createVehicleMesh(vehicleType, color, actualWidth, actualLength);

            mesh.position.set(x, 0, z); mesh.rotation.y = rot; scene.add(mesh);
            vehicle.mesh = mesh; 
            
            const leftLight = mesh.getObjectByName("leftTailLight");
            const rightLight = mesh.getObjectByName("rightTailLight");
            if (leftLight) vehicle.tailLightMaterials.push(leftLight.material);
            if (rightLight) vehicle.tailLightMaterials.push(rightLight.material);

            vehicle.indicators = {
                fr: mesh.getObjectByName("indicator_fr"),
                rr: mesh.getObjectByName("indicator_rr"),
                fl: mesh.getObjectByName("indicator_fl"),
                rl: mesh.getObjectByName("indicator_rl")
            };
            vehicle.speed = vehicle.maxSpeed;
            cars.push(vehicle);
        }

        function updateCars(dt) {
            const INDICATOR_DISTANCE = 70;

            for (let i = cars.length - 1; i >= 0; i--) {
                const c = cars[i];
                if (!c.mesh) { cars.splice(i, 1); continue; }

                if (c.isTurning) {
                    updateTurn(c, dt);
                    continue;
                }

                if (Math.abs(c.mesh.position.x) > ROAD_LENGTH / 2 + 20 || Math.abs(c.mesh.position.z) > ROAD_LENGTH / 2 + 20) {
                    scene.remove(c.mesh); c.mesh.traverse(o => {if (o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose()}); cars.splice(i, 1); continue;
                }

                let targetSpeed = c.maxSpeed;
                const carLength = c.actualLength;

                let minGap = Infinity;
                let frontCar = null;
                cars.forEach(o => {
                    if (c === o || c.isTurning || o.isTurning || c.direction !== o.direction) return;
                    
                    if (c.direction === Direction.SOUTH || c.direction === Direction.NORTH) { // Vertical
                        if (Math.abs(c.mesh.position.x - o.mesh.position.x) > 1) return;
                    } else { // Horizontal
                        if (Math.abs(c.mesh.position.z - o.mesh.position.z) > 1) return;
                    }

                    let gap;
                    if (c.direction === Direction.SOUTH)      gap = o.mesh.position.z - c.mesh.position.z;
                    else if (c.direction === Direction.NORTH) gap = c.mesh.position.z - o.mesh.position.z;
                    else if (c.direction === Direction.WEST)  gap = c.mesh.position.x - o.mesh.position.x;
                    else if (c.direction === Direction.EAST)  gap = o.mesh.position.x - c.mesh.position.x;
                    
                    if (gap > 0 && gap < minGap) { minGap = gap; frontCar = o; }
                });
                
                if (frontCar) {
                    const stoppingGap = (carLength / 2) + (frontCar.actualLength / 2) + 2.5; 
                    const safeFollowingDistance = stoppingGap + c.speed * c.followingTime;
                    if (minGap < safeFollowingDistance) {
                        targetSpeed = minGap < stoppingGap ? 0 : c.maxSpeed * ((minGap - stoppingGap) / (safeFollowingDistance - stoppingGap));
                    }
                }

                let light, stopLine, pos, distStop;
                if (c.direction === Direction.SOUTH)      { light = controller.stateV; stopLine = STOP_LINE_N; pos = c.mesh.position.z; distStop = stopLine - pos; }
                else if (c.direction === Direction.NORTH) { light = controller.stateV; stopLine = STOP_LINE_S; pos = c.mesh.position.z; distStop = pos - stopLine; }
                else if (c.direction === Direction.EAST)  { light = controller.stateH; stopLine = STOP_LINE_W; pos = c.mesh.position.x; distStop = stopLine - pos; }
                else if (c.direction === Direction.WEST)  { light = controller.stateH; stopLine = STOP_LINE_E; pos = c.mesh.position.x; distStop = pos - stopLine; }
                
                const PREPARE_TURN_DISTANCE = 35;
                const TURN_SPEED_FACTOR = 0.9;
                if (c.wantsToTurn && distStop > 0 && distStop < PREPARE_TURN_DISTANCE) {
                    targetSpeed = Math.min(targetSpeed, c.maxSpeed * TURN_SPEED_FACTOR);
                }
                
                if (c.wantsToTurn && !c.isTurning && c.blinkerState === 'off' && distStop > 0 && distStop < INDICATOR_DISTANCE) {
                    c.blinkerState = 'left'; // All implemented turns are left turns
                }
                if (c.blinkerState !== 'off') {
                    c.blinkerTimer += dt;
                    const isOn = Math.floor(c.blinkerTimer / 0.25) % 2 === 0;
                    if (c.blinkerState === 'right') {
                        if (c.indicators.fr) c.indicators.fr.visible = isOn;
                        if (c.indicators.rr) c.indicators.rr.visible = isOn;
                        if (c.indicators.fl) c.indicators.fl.visible = false;
                        if (c.indicators.rl) c.indicators.rl.visible = false;
                    } else if (c.blinkerState === 'left') {
                        if (c.indicators.fr) c.indicators.fr.visible = false;
                        if (c.indicators.rr) c.indicators.rr.visible = false;
                        if (c.indicators.fl) c.indicators.fl.visible = isOn;
                        if (c.indicators.rl) c.indicators.rl.visible = isOn;
                    }
                }

                const frontBumperDist = distStop - carLength / 2;
                let canTurn = light === LightState.GREEN;

                const mustStopForLight = !canTurn && distStop > 0;
                if (mustStopForLight && frontBumperDist < 60) {
                    let desiredSpeed = frontBumperDist * 1.5;
                    if (desiredSpeed < 0) desiredSpeed = 0;
                    targetSpeed = Math.min(targetSpeed, desiredSpeed);
                }
                
                const isCurrentlyBraking = targetSpeed < c.speed && c.speed > 0.1;
                if (isCurrentlyBraking !== c.isBraking) {
                    c.isBraking = isCurrentlyBraking;
                    if (c.tailLightMaterials.length > 0) {
                        const emissiveColor = c.isBraking ? 0xff0000 : 0xdd0000;
                        const emissiveIntensity = c.isBraking ? 2.5 : 0.4;
                        c.tailLightMaterials.forEach(mat => {
                            if (mat.emissive) {
                                mat.emissive.setHex(emissiveColor);
                                mat.emissiveIntensity = emissiveIntensity;
                            }
                        });
                    }
                }

                c.speed += (targetSpeed - c.speed) * (targetSpeed < c.speed ? c.decelFactor : c.accelFactor);
                if (c.speed < 0) c.speed = 0;

                if (c.wantsToTurn && !c.isTurning && canTurn && c.speed > 0) {
                    let distToTurnPoint = Infinity;
                    if (c.direction === Direction.SOUTH) distToTurnPoint = (-ROAD_WIDTH_H / 2) - c.mesh.position.z;
                    else if (c.direction === Direction.NORTH) distToTurnPoint = c.mesh.position.z - (ROAD_WIDTH_H / 2);
                    else if (c.direction === Direction.WEST) distToTurnPoint = c.mesh.position.x - (ROAD_WIDTH_V / 2);
                    else if (c.direction === Direction.EAST) distToTurnPoint = (-ROAD_WIDTH_V / 2) - c.mesh.position.x;
                    
                    const movementInFrame = c.speed * dt;
                    if (distToTurnPoint > 0 && distToTurnPoint <= movementInFrame) {
                        const timeToReach = distToTurnPoint / c.speed;
                        const remainingDt = dt - timeToReach;
                        
                        c.mesh.translateZ(distToTurnPoint);
                        startTurn(c);
                        
                        if (c.isTurning) {
                            updateTurn(c, remainingDt);
                        }
                        continue;
                    }
                }


                let movement = c.speed * dt;
                const COLLISION_BUFFER = 2.5; const BRAKE_BUFFER = 1.5;
                let maxMovementFromCar = frontCar ? minGap - (carLength / 2) - (frontCar.actualLength / 2) - COLLISION_BUFFER : Infinity;
                let maxMovementFromLight = mustStopForLight ? frontBumperDist - BRAKE_BUFFER : Infinity;
                
                if (movement > Math.min(maxMovementFromCar, maxMovementFromLight)) {
                    movement = Math.max(0, Math.min(maxMovementFromCar, maxMovementFromLight));
                    c.speed = 0;
                }
                
                c.mesh.translateZ(movement); 
            }
        }

        function updateCounters() {
            const counts = { a1: 0, a3: 0, a5: 0, a7: 0 };
            cars.forEach(c => {
                const { x, z } = c.mesh.position;
                if (!c.isTurning) {
                     if (c.direction === Direction.SOUTH && z > (STOP_LINE_N - SENSOR_ZONE_LEN) && z < STOP_LINE_N) counts.a1++;
                     if (c.direction === Direction.NORTH && z < (STOP_LINE_S + SENSOR_ZONE_LEN) && z > STOP_LINE_S) counts.a5++;
                     if (c.direction === Direction.WEST && x < (STOP_LINE_E + SENSOR_ZONE_LEN) && x > STOP_LINE_E) counts.a3++;
                     if (c.direction === Direction.EAST && x > (STOP_LINE_W - SENSOR_ZONE_LEN) && x < STOP_LINE_W) counts.a7++;
                }
            });
            Object.keys(counts).forEach(k => { if (counters[k] && counters[k].val) counters[k].val.innerText = counts[k]; });
            return counts;
        }

        function updateVehicleStats() {
            const totalVehicles = cars.length;
            const stoppedVehicles = cars.filter(c => c.speed < 0.1).length;

            document.getElementById('total-vehicles-count').innerText = totalVehicles;
            document.getElementById('stopped-vehicles-count').innerText = stoppedVehicles;

            // Update Fluidity Index
            const fluidity = totalVehicles > 0 ? ((totalVehicles - stoppedVehicles) / totalVehicles) * 100 : 100;
            const fluidityEl = document.getElementById('fluidity-index-value');
            if (fluidityEl) {
                fluidityEl.innerText = `${fluidity.toFixed(0)}%`;
                fluidityEl.classList.remove('text-green-400', 'text-yellow-400', 'text-red-400');
                if (fluidity > 70) {
                    fluidityEl.classList.add('text-green-400');
                } else if (fluidity > 40) {
                    fluidityEl.classList.add('text-yellow-400');
                } else {
                    fluidityEl.classList.add('text-red-400');
                }
            }
        }

        function updateUIProject() {
            const updatePos = (name, el) => {
                const obj = scene.getObjectByName(`target${name}`);
                if (!obj) return;
                const v = new THREE.Vector3(); obj.getWorldPosition(v); v.project(camera);
                el.style.left = `${(v.x * .5 + .5) * window.innerWidth}px`;
                el.style.top = `${(v.y * -.5 + .5) * window.innerHeight}px`;
            };
            Object.keys(counters).forEach(k => updatePos(k.toUpperCase(), counters[k].el));
        }

        function updateVisualFeedbacks(counts, elapsedTime) {
            const FLASH_DURATION = 0.4;
            const MAX_PRESSURE_COUNT = 8;
            
            // Sensor Flashing
            Object.keys(counts).forEach(key => {
                if(counts[key] > previousCounts[key]) {
                    sensorFlashState[key] = { startTime: elapsedTime };
                }

                if (sensorFlashState[key]) {
                    const timeSinceFlash = elapsedTime - sensorFlashState[key].startTime;
                    if (timeSinceFlash < FLASH_DURATION) {
                        const pulse = Math.sin((timeSinceFlash / FLASH_DURATION) * Math.PI); // Creates a single smooth pulse
                        sensorVisuals[key].material.opacity = 0.35 + pulse * 0.4;
                    } else {
                        sensorVisuals[key].material.opacity = 0.35;
                        delete sensorFlashState[key];
                    }
                }
            });

            // Pressure Bars
            Object.keys(pressureBars).forEach(key => {
                const bar = pressureBars[key];
                const targetScale = Math.min(1, counts[key] / MAX_PRESSURE_COUNT);
                const currentScale = key === 'a1' || key === 'a5' ? bar.scale.y : bar.scale.x;
                const newScale = currentScale + (targetScale - currentScale) * 0.1;

                if (key === 'a1' || key === 'a5') { // Vertical bars (scale on Y)
                    bar.scale.y = newScale;
                } else { // Horizontal bars (scale on X)
                    bar.scale.x = newScale;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta() * SIMULATION_SPEED;
            const elapsedTime = clock.getElapsedTime() * SIMULATION_SPEED;

            if (elapsedTime > nextSpawnTimeNS && cars.length < 150) {
                spawnVehicle('NS');
                const baseInterval = (1.0 - (densityNS / 100 * 0.9)) * 2.5;
                const randomInterval = baseInterval * (0.5 + Math.random() * 1.0);
                nextSpawnTimeNS = elapsedTime + randomInterval;
            }
            
            if (elapsedTime > nextSpawnTimeEW && cars.length < 150) {
                spawnVehicle('EW');
                const baseInterval = (1.0 - (densityEW / 100 * 0.9)) * 2.5;
                const randomInterval = baseInterval * (0.5 + Math.random() * 1.0);
                nextSpawnTimeEW = elapsedTime + randomInterval;
            }
            
            updateCars(dt);
            const counts = updateCounters();
            updateVehicleStats();
            controller.updateLogic(dt, counts);
            controller.animateLights(elapsedTime);
            updateVisualFeedbacks(counts, elapsedTime);
            updateUIProject();
            renderer.render(scene, camera);

            previousCounts = {...counts};
        }

        function onResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const aspect = w / h;
            
            // --- Zoom Adaptable ---
            const baseD = 80;
            // Si la pantalla es más alta que ancha (móvil vertical), aleja la cámara
            // para mantener visible el ancho de la simulación.
            const d = aspect < 1 ? baseD / aspect : baseD;

            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }

        init();
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>