<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación Tráfico WebGL - Vanilla JS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (Global CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Contadores Flotantes (UI) */
        .sensor-counter {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #22d3ee; /* cyan-400 */
            border: 2px solid #06b6d4; /* cyan-500 */
            font-size: 1.8rem;
            font-weight: bold;
            padding: 0.5rem 1.0rem;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 60px;
        }
        .sensor-label {
            display: block;
            font-size: 0.6rem;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: -2px;
        }
        
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.95);
            border: 1px solid #374151;
            backdrop-filter: blur(4px);
        }
    </style>
<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@^0.182.0",
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.34.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>

    <!-- UI: Contadores Flotantes -->
    <div id="counter-v" class="sensor-counter">
        <span id="val-v">0</span>
        <span class="sensor-label">Norte</span>
    </div>
    <div id="counter-h" class="sensor-counter">
        <span id="val-h">0</span>
        <span class="sensor-label">Oeste</span>
    </div>

    <!-- UI: Controles -->
    <div class="absolute bottom-6 left-6 right-6 flex flex-col md:flex-row justify-between items-end gap-4 pointer-events-none z-20">
        
        <!-- Slider Densidad -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto w-full md:w-72">
            <label class="block text-sm font-bold mb-2 text-cyan-400 flex justify-between">
                <span>Densidad Tráfico</span>
                <span id="density-val">50%</span>
            </label>
            <input id="density-slider" type="range" min="1" max="100" value="50" 
                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
        </div>

        <!-- Botón Modo -->
        <div class="ui-panel p-4 rounded-lg shadow-xl text-white pointer-events-auto flex items-center gap-4">
            <div>
                <p class="text-xs text-gray-400 mb-1 uppercase tracking-wider">Estado</p>
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></div>
                    <span id="status-text" class="font-bold text-sm">INTELIGENTE</span>
                </div>
            </div>
            <button id="mode-btn" 
                    class="px-4 py-2 rounded font-bold transition-all bg-cyan-600 hover:bg-cyan-500 text-white shadow text-sm border-b-2 border-cyan-800 active:border-b-0 active:translate-y-0.5">
                Cambiar Modo
            </button>
        </div>
    </div>

    <!-- Lógica Principal -->
    <script>
        window.onload = function() {
            
            // --- CONFIGURACIÓN ---
            const ROAD_WIDTH = 22;
            const ROAD_LENGTH = 220; 
            const LANE_WIDTH = ROAD_WIDTH / 4;
            const SIMULATION_SPEED = 0.3; // Velocidad de simulación
            
            const STOP_LINE_V = 22; 
            const STOP_LINE_H = 22; 
            const SENSOR_ZONE_POS = 30; // Ajustado: más cerca de la intersección
            const SENSOR_ZONE_LEN = 40; 

            const CAR_LENGTH = 4.5;
            const SAFETY_GAP = 4.0; 

            // Enumeraciones
            const Street = { VERTICAL: 'VERTICAL', HORIZONTAL: 'HORIZONTAL' };
            const LightState = { RED: 'RED', YELLOW: 'YELLOW', GREEN: 'GREEN' };

            // Variables Globales
            let scene, camera, renderer, clock;
            let cars = [];
            let density = 50;
            let isSmartMode = true;
            let controller;

            // Elementos DOM
            const elCounterV = document.getElementById('counter-v');
            const elCounterH = document.getElementById('counter-h');
            const elValV = document.getElementById('val-v');
            const elValH = document.getElementById('val-h');
            const elDensityVal = document.getElementById('density-val');
            const elStatusText = document.getElementById('status-text');
            const elStatusDot = document.getElementById('status-dot');
            
            // --- CLASE: Controlador de Semáforos ---
            class TrafficController {
                constructor(scene) {
                    this.stateV = LightState.GREEN; // Cambiado: Ahora la calle Vertical empieza en Verde
                    this.stateH = LightState.RED;    // Cambiado: Ahora la calle Horizontal (Oeste) empieza en Rojo
                    this.timerV = 0;
                    this.timerH = 0;
                    this.cycleTimer = 0;
                    this.transitioning = false;

                    // Tiempos (segundos simulados)
                    this.MIN_GREEN = 4.0;
                    this.MAX_GREEN = 12.0;
                    this.YELLOW_TIME = 2.0;
                    this.FIXED_TIME = 6.0;

                    this.buildInfrastructure(scene);
                    this.updateVisuals();
                }

                buildInfrastructure(scene) {
                    const createBulb = () => new THREE.Mesh(
                        new THREE.SphereGeometry(2.0, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0x111111 }) 
                    );

                    const createStructure = (x, z, rotation) => {
                        const group = new THREE.Group();
                        
                        // Material Negro para postes
                        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.5 });
                        const postHeight = 16;
                        
                        // Postes (span along local X, relative to group center)
                        const p1 = new THREE.Mesh(new THREE.BoxGeometry(1.0, postHeight, 1.0), matBlack);
                        p1.position.set(-(ROAD_WIDTH/2 + 2), postHeight/2, 0);
                        const p2 = new THREE.Mesh(new THREE.BoxGeometry(1.0, postHeight, 1.0), matBlack);
                        p2.position.set((ROAD_WIDTH/2 + 2), postHeight/2, 0);
                        
                        // Viga (spans local X, connects posts)
                        const beam = new THREE.Mesh(new THREE.BoxGeometry(ROAD_WIDTH + 6, 1.0, 1.0), matBlack);
                        beam.position.set(0, postHeight - 1, 0);

                        // Caja Luces
                        // Bulbs will face local -Z of the group
                        const boxWidth = 5;
                        const boxHeight = 9;
                        const boxDepth = 2; // Depth along local Z

                        const box = new THREE.Mesh(new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth), matBlack);
                        // Positioned to one side of the road (local +X) and slightly towards the "back" of the beam (local +Z)
                        // The light's visible face will be at local -Z
                        box.position.set(ROAD_WIDTH/4, postHeight - 6.0, boxDepth/2 - 1); 
                        
                        group.add(p1, p2, beam, box);

                        // Luces: positioned on the "face" of the box, which is local -Z
                        const bulbOffsetZ = box.geometry.parameters.depth / 2 - 0.5; // Offset to place on the face, slightly in
                        
                        const r = createBulb(); r.position.set(ROAD_WIDTH/4, postHeight - 3.5, -bulbOffsetZ); // Local -Z side of box
                        const y = createBulb(); y.position.set(ROAD_WIDTH/4, postHeight - 6.0, -bulbOffsetZ);
                        const g = createBulb(); g.position.set(ROAD_WIDTH/4, postHeight - 8.5, -bulbOffsetZ);
                        
                        group.add(r, y, g);
                        
                        group.position.set(x, 0, z);
                        group.rotation.y = rotation; // Apply rotation around Y-axis
                        scene.add(group);

                        return { r, y, g };
                    };

                    // Vertical light (North side of intersection, beam along World X, faces World -Z traffic)
                    this.lightsV = createStructure(0, ROAD_WIDTH / 2, 0); 
                    // Horizontal light (East side of intersection, beam along World Z, faces World -X traffic)
                    this.lightsH = createStructure(ROAD_WIDTH / 2, 0, -Math.PI / 2);    
                }

                setLightColor(mesh, isActive, colorHex) {
                    mesh.material.color.setHex(isActive ? colorHex : 0x222222);
                }

                updateVisuals() {
                    // Semáforo Vertical
                    this.setLightColor(this.lightsV.r, this.stateV === LightState.RED, 0xff0000);
                    this.setLightColor(this.lightsV.y, this.stateV === LightState.YELLOW, 0xffaa00);
                    this.setLightColor(this.lightsV.g, this.stateV === LightState.GREEN, 0x00ff00);

                    // Semáforo Horizontal
                    this.setLightColor(this.lightsH.r, this.stateH === LightState.RED, 0xff0000);
                    this.setLightColor(this.lightsH.y, this.stateH === LightState.YELLOW, 0xffaa00);
                    this.setLightColor(this.lightsH.g, this.stateH === LightState.GREEN, 0x00ff00);
                }

                switchLight(targetStreet) {
                    if (this.transitioning) return;
                    
                    if (targetStreet === Street.VERTICAL && this.stateV === LightState.GREEN) return;
                    if (targetStreet === Street.HORIZONTAL && this.stateH === LightState.GREEN) return;

                    this.transitioning = true;
                    
                    // Fase Amarillo
                    if (this.stateV === LightState.GREEN) this.stateV = LightState.YELLOW;
                    if (this.stateH === LightState.GREEN) this.stateH = LightState.YELLOW;
                    this.updateVisuals();

                    setTimeout(() => {
                        this.stateV = LightState.RED;
                        this.stateH = LightState.RED;
                        
                        if (targetStreet === Street.VERTICAL) this.stateV = LightState.GREEN;
                        else this.stateH = LightState.GREEN;
                        
                        this.timerV = 0;
                        this.timerH = 0;
                        this.transitioning = false;
                        this.updateVisuals();
                    }, this.YELLOW_TIME * 1000 / SIMULATION_SPEED);
                }

                updateLogic(dt, countV, countH) {
                    if (this.transitioning) return;

                    if (this.stateV === LightState.GREEN) this.timerV += dt;
                    if (this.stateH === LightState.GREEN) this.timerH += dt;

                    if (isSmartMode) {
                        // Modo Inteligente: Prioridad por demanda
                        
                        // 1. Tiempo Máximo excedido y hay alguien esperando -> Cambio Forzado
                        if (this.stateV === LightState.GREEN && this.timerV > this.MAX_GREEN && countH > 0) {
                            this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MAX_GREEN && countV > 0) {
                            this.switchLight(Street.VERTICAL);
                        }
                        // 2. Tiempo Mínimo cumplido y la otra calle tiene más autos -> Cambio
                        else if (this.stateV === LightState.GREEN && this.timerV > this.MIN_GREEN) {
                            if (countH > countV) this.switchLight(Street.HORIZONTAL);
                            else if (countH > 0 && countV === 0) this.switchLight(Street.HORIZONTAL);
                        } else if (this.stateH === LightState.GREEN && this.timerH > this.MIN_GREEN) {
                            if (countV > countH) this.switchLight(Street.VERTICAL);
                            else if (countV > 0 && countH === 0) this.switchLight(Street.VERTICAL);
                        }
                        // 3. Empate o vacío: ciclo lento para no bloquearse
                        else if (countV === 0 && countH === 0) {
                             // Si no hay nadie, mantenemos el verde actual o rotamos muy lento
                             if (this.timerV > 20 || this.timerH > 20) {
                                 this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                             }
                        }
                    } else {
                        // Modo Manual/Cíclico
                        this.cycleTimer += dt;
                        if (this.cycleTimer > this.FIXED_TIME) {
                            this.cycleTimer = 0;
                            this.switchLight(this.stateV === LightState.GREEN ? Street.HORIZONTAL : Street.VERTICAL);
                        }
                    }
                }
            }

            // --- ESCENA PRINCIPAL ---
            function init() {
                const container = document.getElementById('canvas-container');

                // 1. Escena
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf3f4f6); // Gris muy claro

                // 2. Cámara Cenital (Top-Down)
                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                camera.position.set(0, 100, 0); 
                camera.lookAt(0, 0, 0); 
                camera.rotation.z = Math.PI; // Norte hacia arriba

                // 3. Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                // 4. Iluminación
                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 80, 40);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -60;
                sun.shadow.camera.right = 60;
                sun.shadow.camera.top = 60;
                sun.shadow.camera.bottom = -60;
                scene.add(sun);

                // 5. Mundo
                createRoads();
                createSensorVisuals();
                controller = new TrafficController(scene);

                // 6. Eventos UI
                window.addEventListener('resize', onResize);
                
                document.getElementById('density-slider').addEventListener('input', (e) => {
                    density = parseInt(e.target.value);
                    elDensityVal.innerText = density + '%';
                });

                document.getElementById('mode-btn').addEventListener('click', (e) => {
                    isSmartMode = !isSmartMode;
                    if(isSmartMode) {
                        elStatusText.innerText = "INTELIGENTE";
                        elStatusDot.classList.remove('bg-orange-500');
                        elStatusDot.classList.add('bg-green-500');
                        elCounterV.style.display = 'block';
                        elCounterH.style.display = 'block';
                    } else {
                        elStatusText.innerText = "MANUAL (Cíclico)";
                        elStatusDot.classList.remove('bg-green-500');
                        elStatusDot.classList.add('bg-orange-500');
                        elCounterV.style.display = 'none';
                        elCounterH.style.display = 'none';
                    }
                });

                // Iniciar Loop
                clock = new THREE.Clock();
                animate();
                
                elCounterV.style.display = 'block';
                elCounterH.style.display = 'block';
            }

            function createRoads() {
                const roadMat = new THREE.MeshPhongMaterial({ color: 0x555555 });
                
                // Calles
                const vRoad = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH), roadMat);
                vRoad.rotation.x = -Math.PI / 2;
                vRoad.receiveShadow = true;
                scene.add(vRoad);

                const hRoad = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LENGTH, ROAD_WIDTH), roadMat);
                hRoad.rotation.x = -Math.PI / 2;
                hRoad.receiveShadow = true;
                scene.add(hRoad);

                const inter = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_WIDTH), roadMat);
                inter.rotation.x = -Math.PI / 2;
                inter.position.y = 0.01;
                inter.receiveShadow = true;
                scene.add(inter);

                // Líneas
                const yellow = new THREE.MeshBasicMaterial({ color: 0xfacc15 });
                const white = new THREE.MeshBasicMaterial({ color: 0xffffff });

                // Centrales
                for(let i = -ROAD_LENGTH/2; i < ROAD_LENGTH/2; i+=7) {
                    if (Math.abs(i) > ROAD_WIDTH/2 + 2) {
                        const dv = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 3.5), yellow);
                        dv.rotation.x = -Math.PI/2;
                        dv.position.set(0, 0.02, i);
                        scene.add(dv);

                        const dh = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5), yellow);
                        dh.rotation.x = -Math.PI/2;
                        dh.position.set(i, 0.02, 0);
                        scene.add(dh);
                    }
                }
            }

            function createSensorVisuals() {
                const geo = new THREE.PlaneGeometry(ROAD_WIDTH-1, SENSOR_ZONE_LEN);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0x22d3ee, // Cyan
                    transparent: true, 
                    opacity: 0.15, 
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const sv = new THREE.Mesh(geo, mat);
                sv.rotation.x = -Math.PI/2;
                sv.position.set(0, 0.05, SENSOR_ZONE_POS); // Posición ajustada
                scene.add(sv);

                const sh = new THREE.Mesh(geo, mat);
                sh.rotation.x = -Math.PI/2;
                sh.rotation.z = -Math.PI/2;
                sh.position.set(SENSOR_ZONE_POS, 0.05, 0); // Posición ajustada
                scene.add(sh);

                // Objetos invisibles para trackear posición 2D
                const tV = new THREE.Object3D(); tV.name = 'targetV'; tV.position.set(0, 0, SENSOR_ZONE_POS); scene.add(tV); // Posición ajustada
                const tH = new THREE.Object3D(); tH.name = 'targetH'; tH.position.set(SENSOR_ZONE_POS, 0, 0); scene.add(tH); // Posición ajustada
            }

            function spawnCar() {
                const colors = [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316, 0x64748b];
                const col = colors[Math.floor(Math.random() * colors.length)];

                // Vertical: de +Z a -Z | Horizontal: de +X a -X
                const rand = Math.random();
                // Ajuste de probabilidad simple para balancear
                const street = rand > 0.5 ? Street.VERTICAL : Street.HORIZONTAL;
                const lane = Math.random() > 0.5 ? 0 : 1; 

                let x=0, z=0, rot=0;

                if (street === Street.VERTICAL) {
                    z = ROAD_LENGTH / 2 + 5; // Spawn bien afuera
                    x = (lane === 0 ? LANE_WIDTH/2 : LANE_WIDTH*1.5);
                    rot = Math.PI; 
                } else {
                    x = ROAD_LENGTH / 2 + 5; 
                    z = (lane === 0 ? -LANE_WIDTH/2 : -LANE_WIDTH*1.5); 
                    rot = -Math.PI/2; 
                }

                // Check seguridad
                const safe = cars.every(c => {
                    if (c.street !== street || c.lane !== lane) return true;
                    const d = c.mesh.position.distanceTo(new THREE.Vector3(x,0,z));
                    return d > 35; // Espacio mínimo para spawnear
                });

                if (!safe) return;

                const grp = new THREE.Group();
                // Carrocería
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.4, CAR_LENGTH), new THREE.MeshStandardMaterial({ color: col }));
                body.position.y = 0.7;
                body.castShadow = true;
                
                // Techo
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                top.position.set(0, 1.75, -0.2);
                
                // Ruedas simuladas (bloques negros simples abajo)
                const wheels = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.5, 3.5), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                wheels.position.y = 0.25;

                grp.add(wheels, body, top);

                grp.position.set(x, 0, z);
                grp.rotation.y = rot;
                scene.add(grp);

                cars.push({
                    mesh: grp,
                    street: street,
                    lane: lane,
                    speed: 0,
                    maxSpeed: 25 + Math.random()*15, // Velocidad variada
                    accel: 15.0
                });
            }

            function updateCars(dt) {
                const limit = -(ROAD_LENGTH/2 + 20); // Límite de despawn
                
                for(let i = cars.length - 1; i >= 0; i--) {
                    const c = cars[i];
                    
                    // Despawn
                    if ((c.street === Street.VERTICAL && c.mesh.position.z < limit) ||
                        (c.street === Street.HORIZONTAL && c.mesh.position.x < limit)) {
                        scene.remove(c.mesh);
                        cars.splice(i, 1);
                        continue;
                    }

                    // Posición lineal
                    const pos = c.street === Street.VERTICAL ? c.mesh.position.z : c.mesh.position.x;
                    
                    // 1. Distancia al de adelante
                    let distAhead = 999;
                    cars.forEach(other => {
                        if (other === c) return;
                        if (other.street === c.street && other.lane === c.lane) {
                            const otherPos = c.street === Street.VERTICAL ? other.mesh.position.z : other.mesh.position.x;
                            // Ambos van hacia negativo. Si 'other' está en 80 y yo en 100, dist es 20.
                            const d = pos - otherPos;
                            if (d > 0 && d < distAhead) distAhead = d;
                        }
                    });

                    // 2. Distancia al semáforo
                    const stopLine = c.street === Street.VERTICAL ? STOP_LINE_V : STOP_LINE_H;
                    const distStop = pos - stopLine;
                    const light = c.street === Street.VERTICAL ? controller.stateV : controller.stateH;
                    const canGo = light === LightState.GREEN;

                    let targetSpeed = c.maxSpeed;

                    // Freno por coche (Prioridad seguridad)
                    if (distAhead < CAR_LENGTH + SAFETY_GAP) {
                        targetSpeed = 0;
                    } else if (distAhead < 30) {
                        targetSpeed = Math.min(targetSpeed, (distAhead - (CAR_LENGTH + SAFETY_GAP)) * 1.5);
                    }

                    // Freno por Semáforo
                    if (!canGo) {
                        // Si estamos acercándonos a la línea (distStop positivo) y dentro de rango (aumentado a 75)
                        if (distStop > 0 && distStop < 75) { 
                            if (distStop < 3) targetSpeed = 0;
                            else targetSpeed = Math.min(targetSpeed, distStop * 1.5);
                        }
                    }

                    // Física simple
                    if (c.speed < targetSpeed) c.speed += c.accel * dt;
                    else c.speed -= c.accel * 3 * dt; // Frenado fuerte

                    if (c.speed < 0) c.speed = 0;

                    const move = c.speed * dt;
                    if (c.street === Street.VERTICAL) c.mesh.position.z -= move;
                    else c.mesh.position.x -= move;
                }
            }

            function updateCounters() {
                const vMin = SENSOR_ZONE_POS - SENSOR_ZONE_LEN/2;
                const vMax = SENSOR_ZONE_POS + SENSOR_ZONE_LEN/2;
                
                let cV = 0, cH = 0;
                cars.forEach(c => {
                    if (c.street === Street.VERTICAL) {
                        if(c.mesh.position.z > vMin && c.mesh.position.z < vMax) cV++;
                    } else {
                        if(c.mesh.position.x > vMin && c.mesh.position.x < vMax) cH++;
                    }
                });

                elValV.innerText = cV;
                elValH.innerText = cH;

                return { cV, cH };
            }

            function updateUIProject() {
                const updatePos = (objName, el) => {
                    const obj = scene.getObjectByName(objName);
                    if(!obj) return;
                    
                    const v = new THREE.Vector3();
                    obj.getWorldPosition(v);
                    
                    // Ajuste visual para no tapar los coches
                    if (objName === 'targetV') v.x += 20; 
                    if (objName === 'targetH') v.z -= 20; 

                    v.project(camera);
                    
                    const x = (v.x * .5 + .5) * window.innerWidth;
                    const y = (v.y * -.5 + .5) * window.innerHeight;

                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;
                };

                updatePos('targetV', elCounterV);
                updatePos('targetH', elCounterH);
            }

            let spawnTimer = 0;

            function animate() {
                requestAnimationFrame(animate);
                
                const dt = clock.getDelta() * SIMULATION_SPEED;
                
                // Spawn
                spawnTimer += dt;
                // Intervalo basado en densidad (100% = rapido, 1% = lento)
                const interval = 3.5 - (density/100 * 3.2); 
                if (spawnTimer > interval) {
                    spawnTimer = 0;
                    if(cars.length < 50) spawnCar();
                }

                updateCars(dt);
                const counts = updateCounters();
                controller.updateLogic(dt, counts.cV, counts.cH);
                
                updateUIProject();
                renderer.render(scene, camera);
            }

            function onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 65;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Init
            init();
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>